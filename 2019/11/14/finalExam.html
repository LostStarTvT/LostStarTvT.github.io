<!DOCTYPE html>
<html lang="en">

  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#546E7A">

    

    <title>研一算法考试题目总结</title>

    
      
    

    <link rel="canonical" href="www.diaowenjie.cn/2019/11/14/finalExam.html">

    
    <meta name="keywords" itemprop="keywords" content="blog,css,html,php">
    <link rel="shortcut icon" sizes="128x128" href="/avatar/favicon.png">

    <meta name="robots" content="noarchive">

   
    <style>
.site-header {
   background-color: #546E7A;
   }
.page-header {
   background: url("https://api.dujin.org/bing/1920.php") no-repeat center; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size:cover; max-width:100%; margin: auto;text-align: center;margin-bottom:20px;
}
</style>

    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/fade.css">
    <meta name="google-site-verification" content="tb5-LFfZ4ccQdqYC0-JKdEi3uWBF3IFo8PNsDcahigs" />
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">刁文杰的博客</a>
    

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#ffffff" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#ffffff" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#ffffff" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
              
                <a class="page-link" href="/Billboard.html">Billboard</a>
              
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
              
                <a class="page-link" href="/archives.html">Archives</a>
              
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/links.html">Links</a>
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/pages/tags.html">Tags</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    
    
    <script>
      var OriginTitile = document.title;
      var titleTime;
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          document.title = '刁文杰的博客 ' + OriginTitile;
          clearTimeout(titleTime);
        }
        else {
          document.title = '刁文杰的博客 ' + OriginTitile;
          titleTime = setTimeout(function() {
            document.title = OriginTitile;
          }, 2000);
        }});

    </script>

    <section class="page-header">
      <h1 class="project-name">研一算法考试题目总结</h1>
      <h2 class="project-tagline"></h2>
      
        <h2 class="project-date">
        <time datetime="2019-11-14T00:00:00+08:00" itemprop="datePublished">
          
          Nov 14, 2019
        </time>
        
        
          • <span itemprop="author" itemscope itemtype=""><span itemprop="name">刁文杰的博客</span></span>
        
        </h2>
      
    </section>

    <section class="main-content fade">

      <article itemscope itemtype="">

  <header class="post-header">
      <link rel="dns-prefetch" href="//cdn.bootcss.com" />
    <h1 class="post-title" itemprop="name headline">研一算法考试题目总结</h1>
    <p class="post-meta">
      <time datetime="2019-11-14T00:00:00+08:00" itemprop="datePublished">
        
        Nov 14, 2019
      </time>
      </p>
  </header>
<script type="text/javascript" async
src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  document.getElementsByTagName("img").className="bbb";  
  </script>
  
  <div itemprop="articleBody">
    <blockquote>
  <p>本篇主要是研一算法期末考试整理出来的期末考试资料，不过其中的算法对于剑指offer还具有一定的参考价值</p>
</blockquote>

<h3 id="常用算法思想解析">常用算法思想解析</h3>

<p>主要有 动态规划，背包问题。贪心算法。还有就是回溯法，快速排序。分支界限法。</p>

<h3 id="不同算法类型的定义">不同算法类型的定义</h3>

<ul>
  <li>
    <p>每个阶段只有一有个状态-&gt;<strong>递推</strong>；</p>
  </li>
  <li>
    <p>每个阶段的最优状态都是有上一个阶段的最优状态得到的-&gt;<strong>贪心</strong>；</p>
  </li>
  <li>
    <p>每个阶段的最优状态都是由之前所有阶段的状态的组合得到的-&gt;<strong>搜索</strong>；</p>
  </li>
  <li>
    <p>每个阶段的最优状态可以从之前某个阶段或某些状态直接的得到而不管之前这个状态是如何得到的-&gt;<strong>动态规划</strong>。</p>
  </li>
</ul>

<p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到，这个性质叫做<strong>最优子结构</strong>。</p>

<p>动态规划就涉及到一个问题。 到了第i个位置， 选或者不选？ 所以说只需要记录前一个状态就行。</p>

<p>但是贪心的话就是，不管是到了哪个位置，我都是要找到最优的选择，也就是说，局部的最优最终会形成最后的最优序列。</p>

<h4 id="快排">快排</h4>

<p>其中在进行分治的时候，需要有一个等号，不然的话有相同数据的时候会出现死锁的情况。</p>

<p>填坑法。 <a href="https://segmentfault.com/a/1190000004410119">参考链接</a></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "stdio.h"
</span>
<span class="c1">//快速排序占坑法。</span>
<span class="kt">int</span> <span class="nf">Partation</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tempNum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">];</span> <span class="c1">//记录第一个数据的位置，因为要占用这个进行数据交换。</span>
    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tempNum</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="c1">//要有一个等号，不然的话相同的数据不知道往哪放。</span>
            <span class="n">right</span><span class="o">--</span><span class="p">;</span>
        <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tempNum</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempNum</span><span class="p">;</span> <span class="err">最后将分割点进行归位。</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span>  <span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">Partation</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
    <span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">//此时确定了第一个位置。</span>
    <span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="一-第一章">一 第一章</h3>

<h4 id="统计数字问题-p8-1-1">统计数字问题 p8 1-1</h4>

<p>现在是运用的是暴力求解</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">count_num</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">//赋值初始化，10个值也即是有十个</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">t</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">==</span><span class="n">t</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="c1">//计算第一个0的个数</span>
        <span class="p">}</span>

        <span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="p">[</span><span class="n">t</span><span class="o">%</span><span class="mi">10</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="c1">//计算高位出现次数相当于暴力求解..</span>
            <span class="n">t</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span><span class="c1">//依次向低位</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"present num of %d is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">count_num</span><span class="p">(</span><span class="mi">34567</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="字典序问题--p8-1-2">字典序问题  p8 1-2</h4>

<p>考察一般情况下长度不超过 $k$的升序字符串，假设以第$i$个字符打头的长度不超过k的升序字符串个数为$f(i,k)$，长度不超过k的升序字符串总个数为$g(k)$，则$g(k) = \sum^{26}_{i=1}{f(i,k)}$。易知：</p>

<p>\(f(1,i) = 1  \qquad    \qquad \qquad  \qquad \qquad   \qquad g(1) = \sum^{26}_{i=1}f(i,1) = 26\)<br />
\(f(i,2) = \sum^{26}_{i=i+1}f(j,1) = 26-i   \quad \qquad  g(2) = \sum^{26}_{i=1}f(i,2) = \sum^{26}_{i=1}(26-i)=325\)</p>

<p>一般情况下：<br />
\(f(i,k) = \sum^{26}_{i=i+1}f(j,k-1)  \qquad g(k) = \sum^{26}_{i=1}f(i,k) = \sum^{26}_{i=1}\sum^{26}_{j=i+1}(j,k-1)\)​</p>

<p>据此可以计算出每个升序字符串的编码</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "stdio.h"
#include "string.h"
</span>
<span class="c1">// 总的来说就是，比如说对于一个string 长度为k=4 那么k=3 k=2 k=1 的数量是一定的，可以直接的计算出来，之后在进行累加就行，</span>
<span class="c1">// 之后在进行计算超出来的那些多余的部分。</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="c1">//f函数 第i个字符大头的长度不超过k的升序字符串个数为f(i,k);</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="mi">26</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span>  <span class="c1">//g函数 长度不超过k的升序字符串总个数为g(k)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//26个字母进行循环</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">change</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span>  <span class="c1">//字符串转成数字</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">order</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="c1">//获取1--len-1长度的子字符串数</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">g</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
     <span class="c1">//小于第一个字母的长度为len的所有组合个数</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">change</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="c1">//以第一个字母作为开始的字符串组合个数</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">temp</span><span class="o">=</span><span class="n">change</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">change</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>  <span class="c1">//获取此时的字母并转换为数字</span>
        <span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">//获取此时的长度</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">temp</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">t</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>  <span class="c1">//获取比此时数字小，长度是此时的长度的所有组合的个数</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">len1</span><span class="p">);</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>   <span class="c1">//获取当前字符值，方便下一次从此项+1开始累加</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"输入一个字符串："</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">!=</span><span class="n">EOF</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">order</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"该字符串的字典序为：%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"输入一个字符串："</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="最大间隙问题-p10-1-5">最大间隙问题 p10 1-5</h4>

<p><a href="https://blog.csdn.net/ldutyk/article/details/52475432">参考链接</a></p>

<p>暴力求解 但是不满足线性时间。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="mi">10000002</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">max</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">t</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%lf"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">t</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="n">max</span><span class="p">){</span>
                <span class="n">max</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
            <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%.1lf</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">max</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="http://www.voidcn.com/article/p-nnmchbkc-rp.html">线性时间算法</a></p>

<p>算法思想：</p>

<p>该问题最先想到可能就是排序后计算，但排序的时间复杂度最少为O(nlongn)，不能满足题意的线性时间算法。所以有一个解决该问题的算法，筒排序。</p>

<p>该算法的思想为，将n个数的最大值、最小值找到，在[ min ,max ]区间内，分成n-1个等大的区间，每个区间的大小为 len = （max - min）/（n-1），然后将n个数字填入到这n-1个</p>

<p>区间中，并根据填入的数，找到该区间内数字的最大值与最小值。除去两边的最大值和最小值，只需要将n-2 个数字填入到 n-1个区间中，根据抽屉原理，那至少有一个空的区间，所以，最大间隙一定产生在两个不同区间之间。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#define INF 1&lt;&lt;30
</span><span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
    <span class="kt">double</span> <span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">max</span><span class="o">=-</span><span class="n">INF</span><span class="p">,</span><span class="n">min</span><span class="o">=</span><span class="n">INF</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="n">x</span><span class="p">[</span><span class="mi">105</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">ans</span><span class="p">[</span><span class="mi">105</span><span class="p">],</span><span class="n">max</span><span class="o">=-</span><span class="n">INF</span><span class="p">,</span><span class="n">min</span><span class="o">=</span><span class="n">INF</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//在输入的时候找到最大值和最小值，作为桶的边界</span>
    <span class="p">{</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%lf"</span><span class="p">,</span><span class="n">ans</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">max</span><span class="o">&lt;</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">max</span><span class="o">=</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">min</span><span class="o">&gt;</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">min</span><span class="o">=</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="kt">double</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span><span class="o">-</span><span class="n">min</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//计算等区分的大小</span>

    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">left</span><span class="o">=</span><span class="n">min</span><span class="p">;</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">right</span><span class="o">=</span><span class="n">min</span><span class="o">+</span><span class="n">len</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">left</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">min</span><span class="p">)</span><span class="o">/</span><span class="n">len</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="o">&gt;=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">temp</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">x</span><span class="p">[</span><span class="n">temp</span><span class="p">].</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">temp</span><span class="p">].</span><span class="n">max</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">temp</span><span class="p">].</span><span class="n">max</span><span class="o">=</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">temp</span><span class="p">].</span><span class="n">min</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">temp</span><span class="p">].</span><span class="n">min</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">double</span> <span class="n">Max</span> <span class="o">=</span> <span class="o">-</span><span class="n">INF</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">min</span><span class="o">==</span><span class="n">INF</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">max</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">Max</span><span class="o">&lt;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">min</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">max</span><span class="p">)</span>
            <span class="n">Max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">min</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">max</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">max</span><span class="o">==-</span><span class="n">INF</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">max</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">min</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%lf</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">Max</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="第二章">第二章：</h3>

<h4 id="p38-2-3-改写二分搜索算法">p38 2-3 改写二分搜索算法。</h4>

<p><a href="https://blog.csdn.net/bensonrachel/article/details/78116181">参考链接</a></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
</span><span class="n">using</span>  <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">BIN</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//也就是一个partation分治的算法，意思就是找到最后没有找到时，也就是跳出while循环，输出i j就可以。</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">middle</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

            <span class="c1">//cout &lt;&lt; t;</span>
            <span class="k">return</span> <span class="n">middle</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span><span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">}</span>
     <span class="n">i</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
     <span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span> <span class="n">j</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>

    <span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>


    <span class="n">BIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="第三章-dp问题">第三章： dp问题。</h3>

<p>p78 3-1</p>

<p><a href="https://www.zhihu.com/search?type=content&amp;q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">参考链接</a>讲的很好。</p>

<p>4.设计一个O(n^2)时间的算法，找出由n个数字组成的序列的最长单调递增子序列。</p>

<p>要求：(1)写出分析思路；(2)给出具体算法。</p>

<p>输出样例： 不需要是连续的，</p>

<blockquote>
  <p>input: [10,9,2,5,3,7,101,18]</p>

  <p>Output: 4</p>

  <p>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4</p>
</blockquote>

<p><a href="https://blog.csdn.net/cooper20/article/details/80765897">参考链接</a>现在还没有看懂。</p>

<p>算法思路：从所给数组的第一个数开始，向后依次计算此元素开始的最长单调递增子序列的长度，将次长度记录在max中，找出max的最大值，</p>

<p>并将该递增序列的首元素的下标记录在c中，最后依次序输出。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">//n表示n个数据</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>   <span class="c1">//c为记录列表最大的首元素。b为临时记录变量</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">18</span> <span class="p">};</span> <span class="c1">//测试数组</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//保存第i个数据</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>  <span class="c1">// 从第i个开始编列找出递增数列类似于冒泡排序</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="c1">//如果序列是增加的则进行记录</span>
            <span class="p">{</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>   <span class="c1">//序列小于则进行</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="c1">//记录最大递增长度，和序列的第一个元素的下标位置。</span>
        <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>   <span class="c1">//记录需要输出的序列头一个。</span>
        <span class="p">}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">//计数归1，只有自己的时候是1</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">]);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//根据头的信息，找出依次找出比头大的数据。</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>p78 3-3 整数线性规划问题</p>

<p>考虑下面的整数线性规划问题</p>

\[max\sum^n_{i=1}c_ix_i\]

\[y=\begin{cases} \sum^n_{i=1}a_ix_i \leq b \\\\ x_i为非负整数,1 \leq i \leq n \end{cases}\]

<p>试设计一个解决此问题的动态规划算法，并分析该算法的设计复杂性。</p>

<p>解析：相对于具体的背包问题来说，这个就是m(i,j) 是背包容量为j时，可选物品为1,2,3… 时背包问题的最优值。也就是说ck 对应的就是背包的价值，ak表示的就是物品的重量。 因为ak的累加和是小于j，就是j为背包的容量，能够装的下才可以。</p>

<p><strong>解析</strong></p>

<p>该问题是一般情况下的背包问题，具有最优子结构性质，设所给的背包问题的子问题</p>

\[max \sum^i_{k=1}c_kx_k\]

\[\sum^i_{k=1}a_kx_k \leq j\]

<p>的最优值为$m(i,j)$，即$m(i,j)$是背包容量为$j$，可选的物品为$1,2,\dots,i$时背包问题的最优值，由背包问题的最优子结构性质，可以建立$m(i,j)$的递归式如下：</p>

\[m(i,j) =\begin{cases} max\{ m(i-1,j),m(i,j-a_i)+c_i\} &amp; a_i \leq j  \\\\  m(i-1,j) &amp; 0 \leq j &lt; a_i \end{cases}\]

\[m(0,j)=m(i,0)=0;m(i,j)=-\infty,j&lt;0\]

<p>按照此递归式计算出来的$m(n,b)$具有最优值，算法所需要的计算时间为$O(nb)$。</p>

<p>\5. p79 3-4</p>

<p>0-1背包问题</p>

<p>算法描述：给定n种物品和一个容量为c的背包，物品i的重量为wi，其价值为vi</p>

<p>算法的核心公式：</p>

<p><a href="https://blog.csdn.net/xp731574722/article/details/70766804">参考链接</a>：</p>

<blockquote>
  <p>if(j&gt;=w[i])  //j为容量，此时表示此时第i个物品可以被装下
    m[i][j]=max(m[i-1][j],m[i-1][j-w[i]]+v[i]);
    // m[i-1][j-w[i]]+v[i] 代表含义为 先找到在只有i-1个物品时候，在减去被占物品时的最大值，与不装第i个物品时哪个大。
else        //第i个物品不能够被装下
    m[i][j]=m[i-1][j];  //</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="mi">150</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">v</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>   <span class="c1">//物品价值 补0只是为了方便从1开始。</span>
<span class="kt">int</span> <span class="n">w</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">8</span><span class="p">};</span> <span class="c1">//物品重量</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>                <span class="c1">//记录选中的是哪个物品</span>
<span class="kt">int</span> <span class="n">m</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>             <span class="c1">//m[i][j] 表示在面对第i个物品，且背包容量为j的背包时所能获取的最大价值。</span>
<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span>                <span class="c1">//c表示背包容量。</span>
<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>                 <span class="c1">//物品数量</span>

<span class="kt">void</span> <span class="nf">traceback</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">==</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">])</span> 
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">c</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 解释m[n][c]为最优值，如果m[n][c]=m[n-1][c] ,说明有没有第n件物品都一样，则x[n]=0 ; 否则 x[n]=1。当x[n]=0时，由x[n-1][c]继续构造最优解；当x[n]=1时，则由x[n-1][c-w[i]]继续构造最优解。以此类推，可构造出所有的最优解。（这段全抄算法书，实在不知道咋解释啊。。</span>

 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>   <span class="c1">//两层循环，显示物品数量。</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">c</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  <span class="c1">//背包容量。</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">else</span>
                <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="cm">/*  输出生成的二维数组，最右下角为最大值。
    for(int i=1;i&lt;=6;i++)
    {
        for(int j=1;j&lt;=c;j++)
        {
            cout&lt;&lt;m[i][j]&lt;&lt;' ';
        }
        cout&lt;&lt;endl;
    }
*/</span>
    <span class="c1">//找出哪些是进行选择的。</span>
    <span class="n">traceback</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>\6. p80 3-6 租游艇问题</p>

<blockquote>
  <p>长江俱乐部在长江设置了n个游艇出租站1,2,3….n,游客可以在这些游艇出租站租用游艇，并在下游的热河一个游艇出租站归还游艇，游艇出租站i到游艇出租站j之间的组件为r(i,j)，设计一个算法，计算出从出租站1到出租站n所需要的最小租金。</p>

  <p>测试用例:</p>

  <p>3(站数)  5 15 (第一站到其他相应各站的租金)   7 （第二站到其他相应各站的租金）</p>

  <p>输出 12</p>
</blockquote>

<p><a href="https://www.jianshu.com/p/8989ba120a21">参考链接</a></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#define n 3//站点数
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">p</span><span class="p">;</span><span class="c1">//用数组表示从出租站i到j所用最少费用。</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">50</span><span class="p">][</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">//初始化租金数组</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"请输入从%d到%d费用："</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>  <span class="c1">//b[i][j]表示从i站出发，到j站的费用。  1到2  1到3 2到3 </span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//从两个出租站开始逐步计算每多个出租站之间的最优解 感觉是因为存储的特殊性.. 他是斜着进行存储，相当于floy算法，</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">;</span> <span class="c1">//k一直是1 2 3 4 进行递增的。</span>
            <span class="k">for</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">k</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">j</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="c1">//取最小</span>
                    <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>      
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"最少租金：%d"</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="p">]);</span><span class="c1">//0没使用</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="第四章贪心算法">第四章：贪心算法</h3>

<p>贪心算法也就是 只是关注眼前的事，只要证明了局部最优最后形成的是最优解就行，但是不是随便的一个方面便都可以进行贪心，需要证明他的可行性。</p>

<p>ps 额外的题： 经典的贪心算法的会场安排问题。</p>

<p><img src="/image/greed1.png" alt="img" /></p>

<p><img src="/image/greed2.png" alt="img" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;cstdio&gt;
#include&lt;iostream&gt; 
#include&lt;algorithm&gt; 
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>    
<span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Act</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span><span class="n">act</span><span class="p">[</span><span class="mi">100010</span><span class="p">];</span>

<span class="c1">//排序算法，结束时间升序。</span>
<span class="n">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">Act</span> <span class="n">a</span><span class="p">,</span><span class="n">Act</span> <span class="n">b</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>  
<span class="p">}</span> 
 
<span class="kt">int</span> <span class="nf">greedy_activity_selector</span><span class="p">()</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>   
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="c1">//从最小的开始，也就是i=1 开始是第一个，之后第j个，如果结束时间是大于第i个，则是表示可以执行该活动。之后进行记录可以执行。</span>
        <span class="k">if</span><span class="p">(</span><span class="n">act</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">start</span><span class="o">&gt;=</span><span class="n">act</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">)</span> 
        <span class="p">{</span>  
            <span class="n">i</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>  
            <span class="n">num</span><span class="o">++</span><span class="p">;</span>   
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">num</span><span class="p">;</span>  <span class="c1">//只是单纯的输出能够安排几个活动，其实可以在结构体上再加一个标志位，比如 为true就是可以安排的。</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>  
<span class="p">{</span>  
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%lld %lld"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">act</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span><span class="o">&amp;</span><span class="n">act</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">act</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">start</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">act</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">act</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">act</span><span class="o">+</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">cmp</span><span class="p">);</span>   <span class="c1">//按照结束时间进行升序排序。</span>
    <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="n">greedy_activity_selector</span><span class="p">();</span> 
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">res</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>  

<span class="p">}</span>  
</code></pre></div></div>

<p>p108 4-1 会场安排算法。 贪心算法，也就是那个活动安排的问题。</p>

<p>1 现将活动按照结束时间进行升序排序。</p>

<p>2 以第一个为基准，如果下一个的开始时间小于第一个的结束时间，则可以进行，并将其记为参照点。否则下一个。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Act</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span><span class="n">act</span><span class="p">[</span><span class="mi">100010</span><span class="p">];</span>

<span class="c1">//排序算法，结束时间升序。</span>
<span class="n">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">Act</span> <span class="n">a</span><span class="p">,</span><span class="n">Act</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">greedy_activity_selector</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//从最小的开始，也就是i=1 开始是第一个，之后第j个，如果结束时间是大于第i个，则是表示可以执行该活动。之后进行记录可以执行。</span>
        <span class="k">if</span><span class="p">(</span><span class="n">act</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">start</span><span class="o">&gt;=</span><span class="n">act</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">i</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
            <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">num</span><span class="p">;</span>  <span class="c1">//只是单纯的输出能够安排几个活动，其实可以在结构体上再加一个标志位，比如 为true就是可以安排的。</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%lld %lld"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">act</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span><span class="o">&amp;</span><span class="n">act</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">act</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">start</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> 
    <span class="n">act</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">act</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">act</span><span class="o">+</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">cmp</span><span class="p">);</span>   <span class="c1">//按照结束时间进行升序排序。</span>
    <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="n">greedy_activity_selector</span><span class="p">();</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">res</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>p109 4-2 最优合并问题。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
1.对数组升序和降序 
2.对数据处理不采用覆盖，利用动态更改数组数据
for(m=0;m&lt;n-1;m++)
    a[m+1]+=a[m];
例如：5  12  6  2  这里代表是 5个元素，12个元素和6个元素。
第一次排序：2,5,6,12； 2+5=7，  变为2,7,6,12    min=6
第二次排序：2,6,7,12;  6+7=13,  变为2,6,13,12   min=6+12=18
第三次排序：2,6,12,13, 12+13=25,变为2,6,12,25   min=18+24=42 

序列 a1 a2 a3 a4
长度 5  12  6  2 

第一次比较最小，即小的先合并。a1 + a4 合并到 a1
 a1+a4 a2 a3 a4  
 5+2=7 12 6  2    比较了 7-1=6次
第二次比较,还是要合并到a1 上去   a1+a4+a3 = 7+6= 13
 a1+a4+a3 a2 a3 a4
 5+2+6=13  12 6  2   比较了 13-1=12 次。
同理第三次..
也就是说，


没看懂..
*/</span>

<span class="cp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
</span> 
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// 记录数组输入数组长度，</span>
<span class="kt">int</span> <span class="nf">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">minsum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="c1">//m表示数组长度</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">+</span><span class="n">m</span><span class="p">);</span> <span class="c1">//默认的是升序。</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">//一次把后面的都累加到上面。</span>
        <span class="n">sum</span><span class="o">+=</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="c1">//加完之后需要将排好序的向前移动。 已经加完的</span>
        <span class="p">{</span>
            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">m</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">-</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//因为是m+n -1 所以有几个数字就是会有几个1 ，故减去n个一。</span>
<span class="p">}</span> 
 
 
<span class="kt">int</span> <span class="nf">maxsum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">+</span><span class="n">m</span><span class="p">,</span><span class="n">cmp</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">sum</span><span class="o">+=</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">m</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">-</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> 
<span class="p">}</span> 
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span> <span class="c1">//有几个数字。</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"min:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">minsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"max:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">maxsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="p">));</span>
<span class="p">}</span>

</code></pre></div></div>

<p>p110 4-6 最优服务次序问题</p>

<p>直接贪心算法，排个序，进行累加即可。 因为需要先将小的进行服务。</p>

<p>算法思想：分别计算每个顾客的等待时间，不是淡出的加在一起，如果从头到尾的加一起，那是最后一个顾客等待的时间，所以说需要从头开始加。</p>

<p>又因为不需要显示出每个人的等待时间，所以不需要开辟空间进行记录，只需要从头逐次开始累加。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define N 100 
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">num</span><span class="p">);</span><span class="c1">//先排序 C++</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">num</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">//每个位置累加前面到自己  直接进行覆盖。 </span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">num</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="c1">//加起来</span>
        <span class="n">sum</span><span class="o">+=</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">sum</span><span class="o">/</span><span class="n">num</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>p111 4-9 汽车加油问题。（还没看懂）</p>

<p>汽车应该走到自己能走并且离自己最远的那个加油站，在那个加油站加油之后在在进行执行相同的算法。</p>

<p>先检测各加油站之间的距离，若发现其中有一个距离大于汽车加满油能跑的距离，则输出no solution。
否则，对加油站间的距离进行逐个扫描，尽量选择往远处走，不能走了就让num++，最终统计出来的num便是最少的加油站数</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="c1">// d表示每个加油站距离数组  n 表示加一次有能走多远  k表示总共有多少加油站。</span>
<span class="kt">void</span> <span class="nf">greedy</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//首先检测每个加油站的距离，如其中距离大于加完油也不能跑的，直接输出无结果</span>
        <span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"no solution</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 遍历加油站。 s？？ n表示一次能够走多远。</span>
    <span class="c1">//汽车应该走到自己能走并且离自己最远的那个加油站</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//s进行累加加油站距离。 d[i]表示能够走的距离</span>
        <span class="n">s</span><span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//如又距离大于能走的距离，则进行加油。。？？ 加油之后有又重新更新s</span>
            <span class="n">num</span><span class="o">++</span><span class="p">;</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//重新开始走。 </span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>  <span class="c1">//nkm 表示一次加油机车能够走的距离。  k 表示加油站个数。</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span> <span class="c1">//表示加油站的距离</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">greedy</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

  </div>

    
<footer>
    <div style="color: #B0BEC5">标签：
    
    <a class="tag" style="color: #E91E63;font-weight:bold" href="/pages/tags#Algorithm">#Algorithm</a>
    
  </div>
</footer>






  
  
  

  
  
</article>


      <footer class="site-footer">
        <!-- <span class="site-footer-owner"> 刁文杰的博客©2018-2019.</span> -->
        
      <center>
          <span class="site-footer-credits">刁文杰的博客©2018-2020.</span><br>
          <!-- <span class="site-footer-credits" style="font-size:12px">Already <span id="sitetime"></span> days.</span><br> -->
          <!-- <span class="site-footer-credits" href>浙ICP备2020039014号</span><br> -->
          <a href="http://beian.miit.gov.cn/" class="site-footer-credits"> 浙ICP备2020039014号</a> <br>
      </center>

     
        

      </footer>
    </section>

    

    
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


      <script>
          ajax()
  function ajax(option){
    var xhr = null;
    if(window.XMLHttpRequest){
      xhr = new window.XMLHttpRequest();
    }else{ // ie
      xhr = new ActiveObject("Microsoft")
    }
    xhr.open("get","");
    xhr.send(null);
    xhr.onreadystatechange = function(){
      var time = null,
          curDate = null;
      if(xhr.readyState===2){
        // Get time
        time = xhr.getResponseHeader("Date");
        console.log(xhr.getAllResponseHeaders())
        curDate = new Date(time);
        document.getElementById("sitetime").innerHTML = (parseInt((((curDate.getTime() / 1000) - 1571133419 ) / 86400 )));
        
      }
    }
  }
      </script>
      
      <script src = '/assets/js/instantclick.min.js' data-no-instant></script>
      <script data-no-instant>InstantClick.init();</script>
      
  </body>
</html>
