---
layout: post
title: Java：分布式锁
tags: java
---


> 

##  目录
* 目录
{:toc}
# 1.关系型数据库理论 - ACID

传统的数据库理论主要需要解决的四个问题:

![ACID.png](https://pic.tyzhang.top/images/2020/07/27/ACID.png)



ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。

### **A – Atomicity – 原子性**

一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有被执行过一样。

### **C – Consistency – 一致性**

在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

对于单独的数据来说而已。

### **I – Isolation – 隔离性**

数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

### **D – Durability – 持久性**

事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

关系型数据库严格遵循ACID理论。但当数据库要开始满足横向扩展、高可用、模式自由等需求时，需要对ACID理论进行取舍，不能严格遵循ACID。以CAP理论和BASE理论为基础的NoSQL数据库开始出现。

# 2.分布式系统理论

对于分布式锁来说，也就是redis和Zookeeper和MQ这老三样，然后就是为了实现CAP中的原则然后进行加锁啥的。

主要就是为了要实现CAP三条原则， 对于一个分布式系统来说，分区容错是基本需求，否则不能称之为分布式系统。**因此架构师需要在C和A之间寻求平**。

![cap.png](https://pic.tyzhang.top/images/2020/07/27/cap.png)

CAP理论告诉我们：一个分布式系统不可能同时满足一致性(C:Consistency)、可用性(A:Availability)、分区容错性(P:Partitiontolerance)这三个基本需求，并且最多只能满足其中的两项。对于一个分布式系统来说，分区容错是基本需求，否则不能称之为分布式系统。因此架构师需要在C和A之间寻求平衡。

**这个概念要从分布式的思想去考虑，而不是直接的进行操作。**

### C – Consistency  一致性（与ACID的C完全不同）

一致性是指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。 讲究的是分布式的。

对于一致性，可以分为从客户端和服务端两个不同的视角。

从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。

从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。

从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。

### **A – Availability  可用性**

可用性是指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。

对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是说，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须完成。

好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。在通常情况下，可用性与分布式数据冗余、负载均衡等有着很大的关联。

### **P – Partition tolerance 分区容错性**

分区容错性是指“the system continues to operate despite arbitrary message loss or failureof part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，但看上去却好像是一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其它剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔成未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。

**CA without P**

如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。

**CP without A**

如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。

**AP without C**

要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。

CAP理论定义了分布式存储的根本问题，但并没有指出一致性和可用性之间到底应该如何权衡。于是出现了BASE理论，给出了权衡A与C的一种可行方案。

[参考连接](https://www.jianshu.com/p/2d2a951fe0df) 

# 高并发

一般来说，应用场景可以分为**CPU密集型**和**IO密集型**，大型网站架构索要解决的就是IO密集型问题。

[当我们在谈论高并发的时候究竟在谈什么?](https://xiaomi-info.github.io/2019/06/21/concurrency/)  

> `高并发`的基本表现为单位时间内系统能够同时处理的请求数,
> `高并发`的核心是对CPU资源的**有效压榨**。

# 分布式锁

主要分为redis和zookeeper分布式锁。基于zookeeper的已经懂得了一些，而基于redis的分布式锁还是不是太懂。

## redis分布式锁

其实对于锁来说，主要也就是信号量的设置，并且涉及到异常的处理，比如说客户端或者服务器端的宕机，如果是一个理想的模型那么就不需要这么多复杂的算法来处理异常，分布式锁主要处理的就是异常情况下怎么保证正常的处理流程，

> 黄金定则，事先预想的异常总会发生。

同样redis上的分布式锁也涉及到信号量的设置与删除，如果已经有了信号量则表示申请成功，在使用完成以后还需要将其删除掉，但是就是在使用的过程中容易出现异常：

1. 生成成功以后再没有来得及释放锁之前客户端宕机
2. 在申请成功以后master服务器宕机，并且没有来得及想slave服务器同步，并且在slave故障恢复为master以后，又被别的客户机申请成功。此时理论上有两个客户端持有相同的锁。

对于故障1，可以使用超时机制，如果客户机在一定的时间内失去联系并且没有释放锁，则服务器自动的释放锁。

对于故障2，可以使用全局唯一的UUID限制锁的序号，即在进行操作和释放锁的时候，需要验证客户端进行锁操作的编号，匹配成功才可以。

这种的处理方式其实有点想zookeeper中的事务编号和选举周期，只有满足条件的才能被处理，也就是异常的处理。

## 分布式锁的实现

对于锁的实现，最重要的就是使用原子性性执行操作，并且加上超时释放的操作，其中就有个Lua脚本，可以实现两个操作的原子性操作，需要注意的是，如果两个原子操作是割裂的，并不能组成一个原子性操作，也会出现异常，比如说查询并设置，如果查询是原子性操作，设置是原子性操作，但是查询并设置连接在一起使用就不是一个原子性操作，在并发的情况下就会出现错误。

> 以下内容参考 [基于Redis的分布式锁实现](https://juejin.im/post/6844903830442737671)

## 普通实现

说道Redis分布式锁大部分人都会想到：`setnx+lua`(不安全)或者知道`set key value px milliseconds nx`。**set指令更好**。后一种方式的核心实现命令如下：

```lua
- 获取锁（unique_value可以是UUID等）
SET resource_name unique_value NX PX 30000

- 释放锁（lua脚本中，一定要比较value，防止误解锁）
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

```java
SET key value[EX seconds][PX milliseconds][NX|XX] 
- EX seconds: 设定过期时间，单位为秒
- PX milliseconds: 设定过期时间，单位为毫秒
- NX: 仅当key不存在时设置值
- XX: 仅当key存在时设置值
```

这种实现方式有3大要点（也是面试概率非常高的地方）：

1. set命令要用`set key value px milliseconds nx`；
2. value要具有唯一性；
3. 释放锁时要验证value值，不能误解锁；

value必须要具有唯一性，以用UUID来做，设置随机字符串保证唯一性，至于为什么要保证唯一性？假如value不是随机字符串，而是一个固定值，那么就可能存在下面的问题：

- 1.客户端1获取锁成功
- 2.客户端1在某个操作上阻塞了太长时间
- 3.设置的key过期了，锁自动释放了
- 4.客户端2获取到了对应同一个资源的锁
- 5.客户端1从阻塞中恢复过来，因为value值一样，所以执行释放锁操作时就会释放掉客户端2持有的锁，这样就会造成问题。

所以通常来说，在释放锁时，我们需要对value进行验证。

事实上这类琐最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：

1. 在Redis的master节点上拿到了锁；
2. 但是这个加锁的key还没有同步到slave节点；
3. master故障，发生故障转移，slave节点升级为master节点；
4. 导致锁丢失。

正因为如此，Redis作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：**Redlock**。

### 红锁的实现方式

在Redis的分布式环境中，我们假设有N个Redis master。这些节点**完全互相独立，不存在主从复制或者其他集群协调机制**。我们确保将在N个实例上使用与在Redis单实例下相同方法获取和释放锁。现在我们假设有5个Redis master节点，同时我们需要在5台服务器上面运行这些Redis实例，这样保证他们不会同时都宕掉。

为了取到锁，客户端应该执行以下操作:

- 获取当前Unix时间，以毫秒为单位。
- 依次尝试从5个实例，使用相同的key和**具有唯一性的value**（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。
- 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。**当且仅当从大多数**（N/2+1，这里是3个节点）**的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功**。
- 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
- 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在**所有的Redis实例上进行解锁**（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。

简单的流程为：

- **顺序向五个节点请求加锁**
- **根据一定的超时时间来推断是不是跳过该节点**
- **三个节点加锁成功并且花费时间小于锁的有效期**
- **认定加锁成功**

#### Redisson实现简单分布式锁

对于Java用户而言，我们经常使用Jedis，Jedis是Redis的Java客户端，除了Jedis之外，Redisson也是Java的客户端，Jedis是阻塞式I/O，而Redisson底层使用Netty可以实现非阻塞I/O，该客户端封装了锁的，继承了J.U.C的Lock接口，所以我们可以像使用ReentrantLock一样使用Redisson，具体使用过程如下。

1. 首先加入POM依赖

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.10.6</version>
</dependency>
```

1. 使用Redisson，代码如下(与使用ReentrantLock类似）

```java
// 1. 配置文件
Config config = new Config();
config.useSingleServer()
        .setAddress("redis://127.0.0.1:6379")
        .setPassword(RedisConfig.PASSWORD)
        .setDatabase(0);
//2. 构造RedissonClient
RedissonClient redissonClient = Redisson.create(config);

//3. 设置锁定资源名称
RLock lock = redissonClient.getLock("redlock");
lock.lock();
try {
    System.out.println("获取锁成功，实现业务逻辑");
    Thread.sleep(10000);
} catch (InterruptedException e) {
    e.printStackTrace();
} finally {
    lock.unlock();
}
```

## mysql分布式锁

