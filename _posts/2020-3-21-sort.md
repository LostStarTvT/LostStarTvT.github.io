---
layout: post
title: 排序算法总结
tags: Algorithm  
---


> 记录总结算法中常用的排序代码，以备不时之需，

### 排序算法综述

1. 快速排序
2. 堆排序
3. 冒泡排序
4. 选择排序
5. 插入排序
6. 交换排序
7. 等等

#### 0.前提说明

一下代码使用的交换函数如下所示，直接进行交换

交换函数：  

```java
   void swap(int [] arrays,int i,int j){
        int tmp;
        tmp = arrays[i];
        arrays[i] = arrays[j];
        arrays[j] = tmp;
    }
```

测试代码：  

```java
 public static void main(String[] args) {
        Solution solution = new Solution();
        int [] a = {2,4,1,3,5,9,11,3,15,14,22};
        solution.quickSort(a);
        System.out.println(Arrays.toString(a));
    }
```

**ps:java中自带的排序API**  

```java
import java.util.Arrays;
import java.util.Collections;
Arrays.sort(int [] arrays);
Collections.sort(ArrayList<Intger> arrays);
```

#### 1. 快速排序

**算法思想**：主要就是通过分治思想实现快速排序，即找到一个参考数据（一般采取数组中第一个数据)然后进行分段排序，有点多线程的感觉。    刚开始竟然快排都想不起来。。

**注意事项**：

1. 数据越界的异常情况，
2. 什么时候进行交换，
3. 对于升序来说，需要先进行判断大于基准的右边的大值，然后判断左边的值，
4. 在进行一趟遍历完全以后，需要将基准插入到对应的位置，
5. 最后left ==right 所以用哪个划分都可以，

**具体的代码**

```java
 //快速排序
    private int [] quickSort(int[] array){
        Participate(array,0,array.length - 1);
        return array;
    }

    //通过选择开始的节点 为参数，然后进行划分，知道left > right
    private void Participate(int[] array, int left, int right){
        if (left > right) return;
        int l = left;
        int r = right;
        int tmp = array[left];
        while (left< right){

            //需要先从比基准大的地方开始计算。
            while (left<right && array[right] >tmp){
                right --;
            }
            //先执行的会直接因为right不满足条件而跳出循环，即right会跳转到一个不满足小于基准条件的值，然后left == right，左边也跳出循环
            while (left<right && array[left] <= tmp){ //这里相等就会在右移一位相等。
                left ++;
            }
            //进行交换。
            swap(array,left,right);
        }
        //最后left和right的值会相等。然后跳出循环。 而且指向的值是小于tmp的。

        //最后要将最左边的和left交换。即将参考数据归位。
        swap(array,right,l);
        Participate(array,l,right-1);
        Participate(array,right + 1,r);
    }
```

#### 2.堆排序



#### 3.冒泡排序



#### 4.选择排序



#### 5.插入排序



#### 6.交换排序

