---
layout: post
title: Java：Redis学习记录
tags: java
---


> 学习redis记录

##  目录
* 目录
{:toc}
首先什么叫做redis？他是作为一个优秀的非关系型数据库，之前什么叫做非关系型数据库一直没有搞清楚，其实可以单纯的理解为一个独立化的Java容器集合，类似的，Redis中的数据结构有List，String，Set，ZSet，Hash这五种，简单的五种数据结果其实是对应常用编程软件的五种数据结果，相当于直接将其独立出来，类比于关系型数据库来说，其内存的结构有严格的关系，比较笨重，所以非关系型数据库也就是一个独立的容器，作为一种更加快的持久化方案。另外redis是由C语言开发的，所以效率很高。

# 一、基本数据结构

redis 对象头：

```c
typedef struct redisObject{
    unsigned type:4;         // 对象类型，zest、set、hash等
    unsigned encoding:4; 	 // 对象编码 如 ziplist inset skiplist等
    unsigned lru:24;         // 对象的热度
    int refcount;		     // 引用计数
    void *ptr;				 // 对象的body
}
```

redis中有skiplist,ziplist,SDS,



## String

最近才发现，其实各种数据库来说，编程语言来说，String型数据处理场景最多，比如java中HashMap大部分是使用String作为key存储，还有就是计算机最常用的处理需求就是对于字符串的处理，Redis中采取的是一种SimpleString的方式进行存储，

SDS的存储结构。

## List



## Hash



## Set



## ZSet

这个是使用的跳跃表，什么叫做跳跃表呢？ 也就是将链表的实现数组的那种的线性访问，使得链表同时具有链表和数组的有点，也就是使用空间换效率的典范。

其实也就是每插入一个节点就进行抛硬币，即有百分之五十的概率要不要往上层添加一个点，每层都是如此，在添加一层以后，还要进行抛硬币决定要不要在添加一个，这样概率就是 1/2 * 1/2 * 1/2 ..  一直抛下去，其实相当于一个变形的B+ 树，即最底层是原始链表，然后上层就是索引， 然后每次查找的话都是从最高层进行查找，如果大于目标，则返回向下一层寻找，知道找到对应的目标。

也就说，set其实也就是一个有序的集合。

# 二、网络模型

前提知识。对于网络模型来说，需要进行的操作主要数据读取，数据计算，数据写回。 主要的耗时操作就是网络数据的读取和结果的写入。

虽然redis只有一个线程，但是它的处理速度也是很快，这是为什么呢？ 这样就不得不说下IO的模型，传统来说，如果想要写一个监听连接的服务器，一般都是先使用一个主线程进行死循环阻塞等待连接，如果有连接的话就新开辟一个线程，然后使用该线程服务此次连接，这种服务模型就是叫做BIO，即阻塞模型。它存在的缺陷为：

- 一个连接对应一个线程，如果大量连接的话内存会消耗的非常快
- 大量的线程会致使CPU进行大量的上下文切换，这样的话就非常影响性能
- 线程的新建与销毁也会导致大量的额外消耗。

那么又有一种的网络模型就是select，既然大量开启线程性能的话容易受到影响，那么就是用一个线程进行处理所有的数据的读取与写入，这种线程叫做select选择器，即使用一个线程进行轮询所有的连接，查看有没有完成数据的读取(读取网络数据)，这样就避免了使用大量的线程进行阻塞等待，使用一个线程就可以实现监控所有的连接，对于BIO的方式有了很好的效率提升。

更加好用的就是epoll，这种是使用一种事件驱动的方式，比如说网络数据传输完成以后，会向cpu发送一个中断，这时候cpu就可以知道是哪个连接数据传输成功，然后便开始进行后续的计算工作，但是对于这种的数据并不是使用简单的中断进行实现，而是基于红黑树的查找？

 [如果这篇文章说不清epoll的本质，那就过来掐死我吧！](https://zhuanlan.zhihu.com/p/64138532)

什么叫做零拷贝？

对于一个服务器来说，发送数据的时候如何发送呢？

1. 首先向kernel发送读取文件岛到内存，然后kernel将数据从硬盘中拷贝到内存，该线程能够进行读取数据
2. 然后改线程将调用kernel接口将该数据发送给需要数据的连接，即kernel将数据从内存复制到网卡，然后发送出去

这种情况出现了硬盘->内存->内存->网卡 即kernel会复制多次。

而零拷贝的概念就是kernel将数据从硬盘中直接复制到网卡，不用多次拷贝。实现的前提是，发送的数据不需要使用线程进行数据的处理，比如说发送一个图片，线程不需要处理就可以使用零拷贝函数直接的发送出去，其实也就是一个函数sendfile.

另外还有一个mmap函数。

## epoll

epoll相对select改善了很多。
（1）在使用epoll时，首先会构建epoll对象。
（2）有连接接入时，会插入到epoll对象中，epoll对象里实际是一个**红黑树+双向链表**，fd插入到红黑树中，通过红黑树查找到是否重复
（3）一旦fd就绪，会触发回调把fd的插入到就绪链表中，并唤醒等待队列中的线程。
（4）调用epoll_wait方法时只需要检查就绪链表，如有则返回给用户程序，如没有进入等待队列。

由于epoll把fd管理起来，不需要每次都重复传入，而且只返回就绪的fd，因此减少了用户空间和内核空间的相互拷贝，在fd数量庞大的时候更加高效。

Netty可以选择使用不同的多路复用技术。

## Redis为什么单线程还是很快？

**警告1**：这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）；例如我在测试服务器上查看Redis进程，然后找到该进程下的线程：

主要是因为底层利用了epoll，所以他的主线程不需要向BIO一样一直阻塞进行等待连接，使用epoll事件驱动的话，如果有连接那么就接受连接，而数据的传输则不需要使用主线程去等待，当数据传输完成以后，自动会通知主线程去进行具体的计算操作，因为只有一个线程，所以计算是串行进行的，所以不需要考虑多并发问题，也就是说明虽然是单线程也不会慢。对线程下也会出现很多的不可控的操作，如果线程过多还会出现BIO那种太过的线程会消耗更多的资源以至于性能降低。

另外redis 5.x版本及以前都是单线程处理的，模式如下：

![redisf1e836efb8505d11.png](https://pic.tyzhang.top/images/2020/08/23/redisf1e836efb8505d11.png)

即不会等待网络连接的过程，当内核准备好网络传输的数据以后，便开始执行数据的读取与计算然后写回，因为是单线程操作，所有这种操作多事原子性的操作。

在6.x版本以后，redis引进了子线程进行处理读取与写入，而主线只是单纯的进行计算操作，这种在保持了原子性的同时也达到了速度更快。redis也就是说明了并不是线程越多越好，有时候也是人多事杂，最好的线程就是与cpu核心匹配。这就涉及到线程池的worker数的确定。

其实这个问题可以反问？ 为什么就解决的多线程就是更快的？ 是要多少个线程呢？所以说就是虽然线程很快，但是也要控制线程的数量。



## Redis持久化

redis中共有两种持久化的方案

- 使用AOF日志：AOF日志是连续的增量备份，即将所有的操作日志记录下来，然后进行对应的操作。
- 使用快照rdb。因为redis将所有的数据存储到内存中，所以只要将当前内存中数据状态保存下来，这样便可以一次性保存数据。

其中AOF也就是将所有的操作失误记录到日志，如果出现宕机，那么就对原始数据重新进行一遍事务操作，然后就能恢复到原始的数据。但有个问题就是随着时间的推移，它会越来的越大，而且如果完全依赖于AOF的话，再次重新执行一遍事务日志也会花很多的时间。

RDB的话，就是对当前内存数据进行一个快照，如果宕机则直接恢复快照就好。但是一般都是使用两种方式相结合进行操作。RDB的模式是调用glibc的函数fork一个子进程，快照持久化完全交给子线程进行处理。而父进程继续处理客户端的请求。

其中快照的话有一个隐藏的问题，就是如果redis内存中有一个很大的key，然后后台线程在进行rdb备份的时候，才备份一般，key被删除了，那么该如何处理？ redis中采用了一种叫做**COW操作的情形即copy on write模式**，即redis进行的增删改查都是将该数据段复制一份，然后在复制上的段进行操作，这样就不会和后台备份线程进行资源的竞争，互不干扰的进行操作。

## fsync函数

对于aof来说，其日志的写回磁盘是调用fsync进行，一般是每隔1s中进行一次调用，日志刷新到磁盘上。一般在运维的时候，主节点的redis是不会进行rdb的操作，因为非常的费时，需要遍历整个内存，一般都是交给从节点进行整个内存的遍历，即RDB操作，因为会保证主从节点的数据一致性，所有可以实现整个的操作。

Redis 4.0以后带来了混合型备份模式，即RDB + AOF模式，相当于先使用RDB将整个内存空间进行备份，然后之后的变化在使用aof日志进行记录， 这样周期性的更新RDB，然后在清楚aof进行增量追加，达到性能的折中。aof也不会太大，redis也能更快的恢复。

## 哨兵模式

redis集群中有个哨兵模式，其实也就是使用三个线程一直监听集群中服务器的变化，如果有一台服务器宕机，那么就会很快被检测到，通过心跳包进行判断，在检测到宕机以后，便会通知集群中所有主机集群变化， 如果是主节点宕机，那么，也会控制进行重新并进行数据恢复。

另外也相当于zookeeper的崩溃恢复。

## redis管道

其实只是更改了一下发送指令的次序，做到并发的发送指令，类似于

write -> read -> write ->read

更改为如下：

write->write->read->read 这种方式，然后两次read和write可以一起发送，就相当于重复利用信道，然后效率提升，第一种需要发送两次所有时间更长。

相当于第一条指令等待一下第二条指令，然后同时发送，对于第一条指令来说是wirte写入发送缓冲区以后，就直接返回，然后从read缓冲区进行读取数据，如果为空则等待，第二条指令将数据写到缓冲区，然后一起发送，因为网络的传输时间肯定是大于cpu两次的写入时间的，所以一起发送没有太大的问题，然后就可以一起的等待read数据。

# 三、内存淘汰

触发内存淘汰的两个条件：

1. 对象到期。 因为redis对象可以设置到期时间
2. 内存使用到达阈值。 当内存到达阈值的时候或则OOM错误时就会进行内存淘汰机制。

**内存淘汰理论基础：**

- **LRU** least Frequently Used: 最少最近访问

那么如何表示最少最近访问呢？redis中是使用时间控制，即通过为对象头中记录上一次访问的时间对2的24次方取余的值表示，在进行判断的时候，只需要计算上一次访问与当前时间的与2的24方取余的值的来确定，已经有 多少时间没有被访问，找出空闲时间最长的值进行淘汰。

- **LFU** Least Frequently Used: 最少频率访问 

这个想当于在统计一段时间内该对象被访问的次数，因为虽然最近被访问了，但是被访问的次数很少那么就淘汰。这种模式比LRU更优，但是实现比较负载一点。

## 内存淘汰策略

Redis在使用内存达到某个阈值（通过maxmemory配置)的时候，就会触发内存淘汰机制，选取一些key来删除。内存淘汰有许多策略，下面分别介绍这几种不同的策略。

```python
# maxmemory <bytes> 配置内存阈值
# maxmemory-policy noeviction 
```

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**默认策略**
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

如何选取合适的策略？**比较推荐的是两种lru策略**。根据自己的业务需求。如果你使用Redis只是作为缓存，不作为DB持久化，那推荐选择allkeys-lru；如果你使用Redis同时用于缓存和数据持久化，那推荐选择volatile-lru。

> LRU是Least Recently Used的缩写，即最近最少使用。LRU源于操作系统的一种页面置换算法，选择最近最久未使用的页面予以淘汰。在Redis里，就是选择最近最久未使用的key进行删除。

## 过期数据的删除对Redis性能影响

当我们对某些 key 设置了 expire 时，数据到了时间会自动删除。如果一个键过期了，它会在什么时候删除呢？

**在redis中，是使用定期删除+惰性删除实现的过期策略。**

下面介绍三种删除策略：

- **定时删除：**在这是键的过期时间的同时，创建一个定时器 Timer，让定时器在键过期时间来临时立即执行对过期键的删除。
- **惰性删除：**键过期后不管，每次读取该键时，判断该键是否过期，如果过期删除该键返回空。
- **定期删除：**每隔100ms就**随机抽取**一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删掉。 

**定时删除：**对内存友好，对 CPU 不友好。如果过期删除的键比较多的时候，删除键这一行为会占用相当一部分 CPU 性能，会对 Redis 的吞吐量造成一定影响。

**惰性删除：**对 CPU 友好，内存不友好。如果很多键过期了，但在将来很长一段时间内没有很多客户端访问该键导致过期键不会被删除，占用大量内存空间。

**定期删除：**是定时删除和惰性删除的一种折中。每隔一段时间执行一次删除过期键的操作，并且限制删除操作执行的时长和频率。

具体的操作如下：

- Redis 会将每一个设置了 expire 的键存储在一个独立的字典中，以后会定时遍历这个字典来删除过期的 key。除了定时遍历外，它还会使用惰性删除策略来删除过期的 key。
- Redis 默认每秒进行十次过期扫描，过期扫描不会扫描所有过期字典中的 key，而是采用了一种简单的贪心策略。从过期字典中随机选择 20 个 key；删除这 20 个 key 中已过期的 key；如果过期 key 比例超过 1/4，那就重复步骤 1。
- 同时，为了保证在过期扫描期间不会出现过度循环，导致线程卡死，算法还增加了扫描时间上限，默认不会超过 25ms。

参考

- [一文揭秘单线程的Redis为什么这么快?](https://zhuanlan.zhihu.com/p/57089960)

## 持久化如何处理过期？

前面的文章里面介绍了Redis的两种持久化策略：RDB和AOF。在持久化和数据恢复阶段，对过期key也有一些特殊的处理。

**RDB**

从内存数据库持久化数据到RDB文件：持久化key之前，会检查是否过期，过期的key不进入RDB文件 从RDB文件恢复数据到内存数据库：数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）。

**AOF**

从内存数据库持久化数据到AOF文件：当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令） 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉） AOF重写：重写时，会先判断key是否过期，已过期的key不会重写到aof文件

# 三、常见的问题

## 缓存击穿

这个产生的原因是用户大量请求不存在的值，导致流量都发送到后台数据库中，致使数据库承受大量并发，使得mysql宕机。

解决方案：

- 使用布隆过滤器。
- 缓存空对象，并设计过期时间，但是缓存空对象会占用不必要的控件造成控件的浪费，还有就是出现不一致的情况。 

## 缓存血崩

产生原因： 同一时间大量的缓存失效，致使所有的请求都发送到了mysql数据库。

解决方案：

- redis 高可用，即既然有可能redis挂掉，那么我就多设置几台redis，这样在一台挂掉以后其他还可以接着工作，搭建集群
- 限流降级： 在缓存失效后，通过加锁或者队列来控制数据库写缓存的线程数量，比如对某一个key只允许一个线程查询数据和写缓存。
- 数据预热：即在正式部署之前，先把可能的数据访问一遍，这样大部分的数据都会被加载到缓存中，在即将发生大并发访问前手动触发加到缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

## 缓存穿透

产生原因： 也是因为缓存失效致使，即用户一直大量请求某个值（比如说某一热点数据），结果缓存突然到时失效，然后大量请求冲击到了数据库，使得数据库宕机。算是缓存血崩的单点突破。

解决方案： 

- 设置热点数据永不过期： 从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题
- 加互斥锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可，这种方式将高并发的压力转移到分布式锁，因为对分布式锁的考验很大。
- 使用消息队列进行削峰填谷

