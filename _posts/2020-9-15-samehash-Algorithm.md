---
layout: post
title: Java：一致性hash算法
tags: java
---


> 记录分布式中一致性hash算法的解决方案与思想

##  目录
* 目录
{:toc}
# 一致性Hash算法

对于Hash这个东西之前没有太意识到到底是干什么的，一致性hash算法挺有意思，主要思想就是通过hash算法将海量的数据分布在不同的主机上，虽然这种通过不同的数据进行hash，比如存储海量图片，首先根据文件名进行hash计算，然后将计算的结果对节点数取余，比如说有4个节点，那么就可以机会均匀的出现0 1 2 3 ，根据 0  1  2 3将其分配到不同的节点。理论上这种做法很完美，但是有个严重缺陷就是当有一个节点崩溃宕机以后，所有的需要缓存的文件虽然Hash值不变，但是其位置需要重新hash，即所有的文件都需要移动，因为此时节点数变成了3 那么需要重新计算位置，然后转移到不同的节点，这样开销非常的大，如果新加入一个节点其也是需要所有的数据都需要移动，这样就造成了大面积的缓存血崩。（血崩处理方法：数据预热，热点数据永不过期，随机过期，数据库加锁，加入MQ进行削峰限流） 既然节点是可能变化的，那么就找一个不变化的东西进行计算位置不就行？

![sameHash.png](https://pic.tyzhang.top/images/2020/09/29/sameHash.png)

首先对所有的文件对一个长度为2的32-1进行取模，然后也对主机标识（比如IP，主机名）进行Hash算法， 然后对环进行取模，比如有三个主机那么就会将环分为4个部分，然后将文件的hash值对环取模，这样也会落在环的各个位置，此时顺时针判断文件属于哪一个节点，即文件顺时针在环中看到的第一个节点，那么就是该文件的位置，这样，当主机宕机或者是新加入一个主机时候，只需需要更改部分数据就可以，节省了大量的恢复成本，如上图所示。

但是还有一个问题，就是在环中主机的位置可能分配不是很均匀，这样就会导致数据的不均分分布，那么我们可以使用对主机标识多次hash，即在换上多找几个位子，形成虚拟接地，只要虚拟节点比较多，那么就可以很好更加均匀的分布，

[大白话hash一致性算法](https://www.zsythink.net/archives/1182)