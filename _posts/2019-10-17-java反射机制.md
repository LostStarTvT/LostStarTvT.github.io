---
layout: post
title: Java：反射机制
tags: java 
---

> 介绍了java中的反射机制，并且通过一个具体的例子进行说明其实现原理。主要的作用即获取属性、获取构造方法、获取方法、构建对象。反射说白了也就是在操作方法区的Class对象，Java为程序员留了一个可以操作对象的接口。



## 目录

* 目录
{:toc}
## Class对象

当JVM中开始加载类的时候，都会生成一个描述类的对象：Class对象，该类的Class对象记录了用户自定义类中的所有信息，作为后续生成该类的对象时候的模板，其实有点相当于spring中的BeanDefinition，也就是Bean的描述信息。而且JVM中的方法区只会有一个类对象，既然只有一个类对象，那么为什么不同的对象去调用该类类对象中的方法的时候，比如对象A和对象B同时调用该类对象的方法，为什么不会出现并发问题呢？即同时调用方法的时候，在更改对象A中的数据时候也更新了对象B的数据， 其实这种就是ThreadLocal的思想，因为即更改都是在每一个对象中，和另一个对象是没有关系的，即JVM在调用类对象的方法时候，会隐式的将自己的传递到方法中。其实类对象就相当于是一个抽取出来的公共方法区，因为是不会改变的，他是通过隐式的将具体的对象地址传递进去解决的并发问题。

一个Class对象会包括Field、Method、Constructor这三个对象，都是为了描述一个对象的信息。 

- 参考 [Java反射](https://www.zhihu.com/search?type=content&q=java%E5%8F%8D%E5%B0%84)

## Java反射

Java的反射本质上是进行操作类对象，JVM会为每个Class文件构建一个类对象，这个类对象是唯一的，记录了类文件中所有的属性和方法。JVM在进行创建类的对象的时候，会依照该类对象作为模板进行构建新的对象。那么我们如何操作该类对象呢？ 就是通过反射进行操作，另外，通过反射也是框架的灵魂所在，因为可以通过class类名通过反射进行创建对象，反射也可以获取标注，进行创建对象。

另外，动态代理底层使用的也是反射进行实现，获取其方法，然后进行增强调用。

主要就是通过类名来进行构建具体的对象，正常的效果是使用new对象来进行对象的构建，spring也就是利用这个机制来实现动态代理。以下例子就是说明，```forname``` 表示类名。  

```java
object =(ReflectServiceimpl2)Class.forName( "com.lean.ssm.chapter2.reflect.ReflectServiceimpl").getConstructor(String.class}.newinstance（"张三"）;
```

反射：框架设计的灵魂。  

框架： 也就是半成品软件。利用反射可以将java中开发出来的半成品跑起来。   

好处：
1. 可以在程序运行过程中，操作这些对象，比如说ide中的提示变量方法的功能就是运用java的反射机制
2. 可以解耦程序，提高程序的可扩展性。

一下是java代码在计算机中经历的三个阶段：  

![javaClass.png](https://pic.tyzhang.top/images/2020/09/21/javaClass.png)

**另外，反射是实现框架的机制，但并不是spring的核心思想，spring的思想是解决bean之间的耦合关系。**

## 反射的应用场景

反射常见的应用场景这里介绍`3`个：

- Spring 实例化对象：当程序启动时，Spring 会读取配置文件`applicationContext.xml`并解析出里面所有的 标签实例化到`IOC`容器中。
- 反射 + 工厂模式：通过`反射`消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，`反射`可以使得程序更加健壮。
- JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的`驱动类`时用到反射加载驱动类

开发中有个使用反射的一个很好的例子。比如说一个接口有很多的实现类，如果我想在运行的时候可以进行更改具体的实现类，而不需要进行重新编译，那么就可以通过反射来进行，因为反射可以通过全限定类名进行加载不同的类，其实也就是和spring的配置文件一样，通过配置不同的类，不需要重新的编译，就可以直接的更改实现类。因为是通过

```java
object =(ReflectServiceimpl2)Class.forName( "com.lean.ssm.chapter2.reflect.ReflectServiceimpl").getConstructor(String.class}.newinstance（"张三"）;
```

既然可以通过类名进行加载对应的类，那么就可以更改类型，加载不同的实现类，这样其实也是一种更好的工厂模式。所以说要面向接口编码。

另外IDE是如何知道程序员自定义的属性和方法？即如何进行自动补全？其实就是运用的Java的反射思想进行扫描得到的

## 为什么需要反射？

主要是因为在进行反射的时候，可以不需要知道用户自定义实现的对象内部的细节，即不管你怎么变，我都可以通过反射的机制知道，并且获取到用户自定类中的所有东西，这样就对于扩展性就很好。  

另外，在进行反射的时候，也是需要进行构建用户的对象，然后根据用户定义的包名去找到用户需要制定的东西，也就是，我给你提供好框架，你自己去填就行。所以可以实现通过配置来进行各种操作。  

```xml
<bean id = "userService" class = "cn.proposeme.UserService"></bean>
```

```java
public static  UserService getService(){
    String ClassValue ="Class属性值"; //即配置文件中的类的绝对值
    Class calss = Class.forName(ClassValue);
    UserService service = calss.newInstance();
    return service;
}//返回用户需要的对象
```


## 使用反射的步骤 

对于反射来说，总共分为两部分，

1. 获取对象
2. 操作对象方法、属性、构造器

### 1.获取class对象

获取class**对象**的方式：（核心是获取对象） 字节码对象获取的是。  

1. `Class.forName(“全类名”)`:将字节码加载进内存，返回class对象，（也就是意味着这里已经相当于new功能，出现了新的对象）
   * 多用于配置文件的实现方式，将类名定义在配置文件中，读取文件，加载类。
2. 类名.class :通过类名的属性class获取。
   * 多用于参数的传递
3. 对象.getClass():getClass()方法在object类中定义着。
   * 多用于对象的获取字节码的方式

以上，通过获取字节的方式进行class获取，被获取到的对象不仅可以操作其中public 属性，也可以操作其中的私有属性的方法。   

另外：同一个字节码文件(*.class)在第一次程序运行过程中，只会被加载一次，不论是通过哪一种范式获取得到的。  

对于获取到的字节码对象，我们可以干的事，即通过class对象我们可以反过来获取到加载过来的对象。 	

### 2.使用class对象中的方法  

- Class对象功能
  - 获取成员变量们
    - `File[] getFields() ` 获取所有的属性
    - `File[] getField(String name) `通过属性名来获取具体的属性
    - 
    - `File[] getDeclaredFields()`  
    - `File[] getDeclaredField(String name)`
  - 获得构造方法们
    - `Constructor<?>[] getConstructors()`
    - `Constructor<T>[] getConstructor(类<?>... parametterTypes)`
    - 
    - `Constructor<T>[] getDeclaredConstructors()`
    - `Constructor<T>[] getDeclaredConstructor(类<?>... parametterTypes)`
  - 获得成员方法们
    - `Method[] getMethods()`
    - `Method getMethod(String name, 类<?>... parametterTypes)`
    - 
    - `Method[] getDeclaredMethods()`
    - `Method[] getDeclaredMethod(String name, 类<?>... parametterTypes)`
  - 获取类名
    - `String getName()`

**其中Declared与不带Declared的区别：**

使用带Declared的方法可以获取到Class中所有权限的属性和方法，不带的话只能获取到public修饰的属性和方法。   

在使用Declared的时候需要设置一个setAccessible(true) 的属性(file 对象方法)。


## 通过反射进行操作对象的一个例子

总共有两个类```Student.java```和```TestDemo.java```，其中在TestDemo中通过反射的机制来实现构建Student对象，并进行操作。   

ps:代码参考为b站视频，[Java反射]( https://www.bilibili.com/video/av56351262/?p=1 )

```java
/**
 * @author Seven
 * @description 学生类，进行测试反射
 **/
public class Student {
    String name = null;
    int age;
    
    public Student() {
    }
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
	// get and set     
    
    public void say(){
        System.out.println("say...");
    }
    
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



```java
TestDemo.java类。
/**
 * @author Seven
 * @description 通过反射进行构建用户的对象。调用对象的方法。
 * @create 2019-10-16 21:22
 **/

public class TestDemo {

    @Test
    public void reflectTest() throws NoSuchFieldException {
        Class studentClass = Student.class;

        // 获取用户所有的属性对象
        Field[] nameFields = studentClass.getDeclaredFields();
        for (Field field : nameFields){
            System.out.println(field);
        }

        System.out.println("----------------");
        // 获取对象所有的方法名称
        Method[] methodFields = studentClass.getDeclaredMethods();
        for (Method field : methodFields){
            System.out.println(field);
        }
    }

    public static void main(String[] args) throws Exception {

        // 1、通过类名获取student类
        Class studentClass = Class.forName("Reflect.Student");
        // 2、通过student获取类的构造器
        Constructor constructor = studentClass.getConstructor();
        // 3、调用构造器的newInstance方法进行构造对象，并进行强转，获取用户对象。
        Object obj = constructor.newInstance(); //调用的是空构造器。
        // 此时获取到的对象就相当于用户new出来的对象，可以调用其方法。但是也可以通过反射的方法进行调用用户的方法。

        // 4、接着就是通过反射进行调用对象的方法。 需要制定具体的方法名称。
        Method studentMethod = studentClass.getMethod("say");
        // 5、执行对象的方法,调用say方法
        studentMethod.invoke(obj);

        // 6、同理也可以对属性进行相同的操作。 需要制定具体的属性名称
        Field name = studentClass.getDeclaredField("name");

        // 6.1 设置属性。
        name.set(obj,"ccc"); //更改属性的名称为ccc
        // 6.2 判断有没有进行设置成功
        System.out.println(obj);
        // 6.3 通过get方法获取属性值
        Object object = name.get(obj); //获取到其中的值。
        System.out.println(object);
    }
}
```

其中运行reflectTest的结果如下：  

```shell
java.lang.String.Reflect.Student.name
int Reflect.Student.age
--------------------------
public java.lang.String.Reflect.Student.getName()
public void Reflect.Student.setName(java.lang.String)
public void Reflect.Student.say()
public int Reflect.Student.getAge()
public void Reflect.Student.setAge()
```

运行main的结果如下:  

```shell
say....
Student{name ='ccc', age=0}
ccc
```



