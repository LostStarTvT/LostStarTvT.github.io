---
layout: post
title: Java：Zookeeper
tags: java
---


> zookeeper学习总结。

##  目录
* 目录
{:toc}
# 背景

> 分布式系统是一个听见或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。其特点如下：
>
> - 分布性
> - 对等性
> - 并发性
> - 缺乏全局时钟
> - 故障总会发生 任何在设计阶段考虑到的异常情况，一定会在系统实际运行中发生。

为什么需要分布式计算呢？ 主要是为了解决单点故障的问题和降低成本，大型机器虽然性能强劲但是造价高且出问题的话直接服务不可用。什么叫做单点故障？ 即传统的计算机架构都是在一台机器上运行，性能很好正常情况下是没有问题的，但是如果一天它挂了，那么就不能再向外部提供服务，但是如果是有两台机器的话，一台挂掉，那么另外一台还能用，这样就解决了单点故障的问题。那么既然增加一台会好一点，那么增加到一个集群不就更好？多台机器还能进行负载均衡，保证全天24小时能够稳定的提供服务，这也就是分布式集群产生的背景。

但是因为用户是不知道服务的背后是一个计算机集群，他们要的是能够提供服务就行，即把集群当成一台永不宕机的机器，对于集群问题来说首先要考虑的就是数据同步的问题，其实也就是事务处理的问题，如果数据不更改那么就不会出现数据的不一致问题，如果更改了那么所有机器上的数据都要进行更改。

对于传统的数据库来说，因为是单台机器所以事务机制比较好处理，对应的理论为ACID:

- Atomicity 原子性
- Consistency 一致性
- Isolation 隔离性
- Durability 持久性

但当到了分布式集群中时进行处理事务的时候，对应的指导理论为CAP：

- **Consistency 一致性** 当一个系统在数据一致的状态下执行更新操作后，应该保证系统数据仍然是一致的。
- **Availability 可用性**  集群服务一直可用
- **Partition Tolerance 分区容错**  分布式系统在遇到任何网络分布故障的时候，任然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络都发生了故障。

一般来说，一个分布式系统同时只能满足CAP中的两个原则，即只能在CA之间进行权衡，因为是分布式分区容错是必须的。

基于以上的分析，又有人提出了BASE理论：

- **Basically Available  基本可用**   当有故障的时候，可以进行服务降级而不是直接停止服务
- **Soft State 软状态**  即允许系统中存在数据的中间状态，即允许副本同步时候有延迟
- **Eventually consistent 最终一致** 并不需要实时同步，即过了一段时间在进行同步，但最终是要一致。

# 一致性协议

一致性协议按照发展有三种，2PC，3PC，Paxos算法。(Two-Phase Commit 二阶段提交)，对于这些一致性协议来说，很重要的一点就是需要选择出来一个Leader来领导这些集群服务器，以此来完成事务的处理，也就是一种中心化的解决方案。

[2PC、3PC算法](https://blog.csdn.net/qq_42253147/article/details/94868436) 其实也就是事务的同步问题，

## 2PC

2PC就是一个事务发起者向所有的分布式机器先发布一条消息说我要进行数据更新了，然后所有的机器发送一条ACK并且锁定数据等待事务操作，等到所有的机器准备好以后，然后事务发起者在发送一天确认消息，所有的机器同时执行事务操作，事务执行成功。理想情况下这是没有问题的，但是因为是分布式集群，容易出现一台机器的掉线或者是网络的波动等问题，当有问题的时候，便会出现各种不可控的情况。如下所示，左边为准备提交事务的正常流程，右边为提交过程中出现中断的情况。

![2pcnormal.png](https://pic.tyzhang.top/images/2020/07/31/2pcnormal.png)



缺陷：

1、同步阻塞：最大的问题即同步阻塞，即：所有参与事务的逻辑均处于阻塞状态。
2、单点：协调者存在单点问题，如果协调者出现故障，参与者将一直处于锁定状态。
3、脑裂：在阶段2中，如果只有部分参与者接收并执行了Commit请求，会导致节点数据不一致。

## 3PC

3PC，三阶段提交协议，是2PC的改进版本，即将事务的提交过程分为CanCommit、PreCommit、do Commit三个阶段来进行处理。事务的发起者称协调者，事务的执行者称参与者。

![3pc.png](https://pic.tyzhang.top/images/2020/07/31/3pc.png)

优点：降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务。

缺陷：脑裂问题依然存在，即在参与者收到PreCommit请求后等待最终指令，如果此时协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。

## Paxos

具体参考：[如何浅显易懂的说明paxos算法？](https://www.zhihu.com/question/19787937) Paxos算法是一种基于传输且具有高度容错特征的一致性算法，是目前公认的解决分布式一致性最有效的算法之一。

> Paxos算法解决的就是如何在一个可能发生宕机或网络异常的分布式系统中，快速且正确的在集群中对某个数据的值达成一致。并且保证不论发生以上任何异常都不会破坏整个系统的一致性。

其实做的事有三件

1. 使用投票协议选出一个Leader，半数服务器同意则Leader产生
2. Leader使用投票协议发布一个事务的提交，如果半数以上的机器同意，则该事务会被提交
3. 如果Leader挂掉，快速重新选出一个Leader，并且进行事务的恢复。

如果说与3PC的区别，就是这里面加了一个过半就表示该提议必须要接受 ，相当于投票少数服从多数，还有就是提议的序号是递增的，如果当前协议为n，则表示0-n-1的协议都已经被接受。

Paxos算法的一个重要的实现就是Chubby，他是一个面向松耦合分布式系统的锁服务，通常用于为一个由大量小型计算机构成的松耦合分布式系统提供高分布式锁服务。它与zookeeper一样，也是有Master的选取。

## ZAB协议

ZAB协议(Zookeeper Automic Broadcast)，Zookeeper原子消息广播协议，他是作为zookeeper服务器集群中保持数据一致性的核心算法。其思想不完全是Paxos算法，但是也比较相似。ZAB协议中，将服务器分为Leader 和Follower，新版本还加上了Observer。

> ZAB协议并不像Paxos算法那样，是一种通用的分布式一致性算法，他是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。Zookeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据一致性。

其实上面也就是说明了，zookeeper只是保持了自己集群中的数据一致性，算是Paxos对于一种具体的应用，他们之间的区别在于：两者的设计目标不太一样，ZAB协议主要用于构建一个高可用的分布式数据主备系统，例如zookeeper，而Paxos算法则是用于构建一个分布式一致性状态机系统。

以上也就说明了，zookeeper并不是在保持一个机房中所有机器的数据一致性，而只是保证zookeeper集群中主机上的数据一致性，即通过这个一致性的集群为其他机房提供服务器，只是解决的是保证一个单一应用的服务器集群中的数据一致性。

zookeeper的事务处理方式：

> 所有的事务请求都必须有一个全局唯一的服务器来进行协调处理器，这样的服务器被称为Leader服务器，而余下的其他服务器则成为Follower服务器。Leader服务器负责将一个**客户端事务请求**转化成一个事务Proposal（提议），并将该Proposal分发给集群中所有的Follower服务器，之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower服务器分发commit消息，要求其将前一个Proposal提交。

以上就是一个事务的的处理逻辑，需要注意的是，这是客户端请求更改zookeeper服务器上的数据，那么在更改成功以后，zookeeper集群中所有的主机上的数据都要进行更改一致，达到一致性的要求。

可能觉得上面的逻辑也很简单，主要这是理想情况下的处理逻辑，但是在生产环境中异常往往是不能避免的，所有就需要ZAB这种协议去处理异常，比如说Leader主机突然重启，或者是直接宕机，那么此时在处理的事务就需要能够有效的恢复并且满足BASE原则。

### 消息广播

Zookeeper的消息广播类似于2PC提交的过程，即Leader发送一个Proposal向其他所有服务器，当其他服务器收到时便会将其以事务的形式写进日志，然后反馈给Leader服务器一个ACK，当Leader已经收到半数Follow的ACK后，便会广播Commit消息给所有的Follower进行事务的提交，服务器本身也会进行事务的提交。此时便完成了事务。

另外，ZAB协议的事务具有FIFO的特征，并且事务的ID(ZID)是一个具有全局单调递增的ID，所以可以保证事务的顺序性，另外这个ZID也是进行Leader选举的重要参考标准，即给的最大谁就是Leader，从而减少事务的损失。

### 崩溃恢复

当Leader服务器出现崩溃，或者是由于网络原因导致Leader与过半Follower失去联系，这时候就会进入到崩溃恢复模式。恢复模式结束后便会选出一个新的Leader，并让所有的集群都知道已经产生新的Leader。在进行Leader的重新选取过程中，首先会判断当前选举的轮次epoh，即选取周期，避免在崩溃恢复的时候新加入的一台机器进入选举，具有最大的且相同周期的才能进入选取，然后会对比每台机器的ZID，即找到具有最大的ZID的服务器，即表明该服务器提交的事务是最新的，日志里面包含了最完善的事务处理信息，如果ZID相等，那么就比较主机的编号，最大的胜任。

总的来说就是，先确认选取周期是否是一致并且是最大的，然后找到具有最大的ZID，如果ZID相同，那么就找打最大的服务器编号，作为新的Leader，也就是用最简单的协议尽快的选出Leader。（新形成的集群的Leader选取方式也是如此）

### 数据同步

当产生新的Leader以后，服务器便根据自己的日志为每一个Follower准备一个队列，将已经提交的事务正确的同步到每一个Follower的内存中。具体的，Leader在发送Proposal的以后会接着发送一个commit表示该事务已经被提交。

此时如果崩溃的Leader重新加入集群，那么在选举的时候epoh已经不对，所以已经无法参与选举，所以当其重新加入的时候，会根据新Leader的Proposal将自己的事务回退，从而保持数据的一致。

### zook中的三种角色

Leader和Follower和Observer，其中Observer和Follower功能差不多只是Observer不参与Leader的选举。

# Zookeeper





zookeeper是一个典型的分布式数据一致性的解决方案，其解决的问题为： 在zookeeper集群中所有主机的数据都是一致的，

>  zookeeper 是一个典型的分布式数据一致性的解决方案。分布式应用程序可以基于它实现注入数据发布、订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。

zookeeper 致力于提供一个高性能、高可用，且具有严格的顺序访问控制能力（主要是写操作的严格顺序性）的分布式协调服务。

## 数据结构

zookeeper数据结构是一种类似于树形的结构，另外基于zookeeper也可以实现分布式锁，因为他的事务请求是具有严格的顺序的，所以可以形成一种公平锁的情况，即先来先服务器，具体的做法就是使用临时递增节点，然后使用Watcher时间进行监听，实现资源的的顺序执行。