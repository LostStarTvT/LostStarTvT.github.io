---
layout: post
title: Spring：IOC & AOP
tags: java 
---

> 本篇文章主要介绍是IOC和DI，介绍其注解的方式实现，并设置一个例子进行说明

##  目录
* 目录
{:toc}
## 零、为什么需要Spring？

spring两大核心IOC(inversion of control，控制反转)和DI(dependency injection, 依赖注入),其中，IOC是一种设计思想，DI可以说是一种实现方案。  

**ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。**  

也就是说，甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了，比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，并不需要自己去直接找到一个卖家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这下好了，甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。    

什么叫做依赖？依赖的意思可以理解为，我要干什么事，需要依赖于什么东西，比如学生的生活依赖于父母，表现在代码上就是在新建学生对象的时候，必须新建父母对象，然后构成依赖关系。例如：

```java
//用户DAO
public class UserDAO {

    private String database;

    public UserDAO(String dataBase) {
        this.database = dataBase;
    }
    public void doSomething() {
        System.out.println("保存用户！");
    }

}

//用户service
public class UserService {

    private UserDAO dao;

    public UserService(UserDAO dao) {
        this.dao = dao;
    }
    public void doSomething() {
        dao.doSomething();
    }
}

//用户controller
public class Controller {

    public UserService service;

    public Controller(UserService userService) {
        this.service = userService;
    }

    public void doSomething() {
        service.doSomething();
    }

}

//使用的情况
public static void main(String[] args) {

    UserDAO dao = new UserDAO("mysql");
    UserService service = new UserService(dao);
    Controller controller = new Controller(service);

    controller.doSomething();

}
```

从上面的例子可以看出，最后controller的使用必须依赖UserDao和UserService对象。在这里其实就出现一个问题，如果某个对象任意一个构造方法出现了改变，或则是换了一个类进行实现功能， 那么所有的对象构建都要重写，new 之后的构造方法也要重写，需要传递的变量也要修改，另外，如果构造方法参数改变，则也需要大规模的更改，这样的话在一个大型项目中修改的成本是不可估量的。  

而spring的话就是将构造对象的交给spring去维护，程序员只需要向spring 申请对象即可，程序员不需要使用new关键字，只需要进行配置xml文件即可。  

主要思想也就是将对象之间进行解耦，一个对象的更改不会影响另外一个对象的使用，相当于spring提供一个第三方的功能，我需要的东西不需要我自己去找，交给spring帮我办理即可。相当于淘宝系统，买家和卖家不需要认识，直接交给淘宝处理即可。我想用的对象直接申请就行。相当于我只要服务而不需要服务是怎么提供的，接口回调的思想。

[知乎上一个例子](https://www.zhihu.com/question/23277575)：另，[掘金上的例子](https://juejin.im/post/5d78a9f1e51d453b1f37ebb6)    

手动的创建一个Car实例，需要轮子，底盘，框架，最后返回一个新的Car对象   

[![springDemo1.jpg](https://pic.tyzhang.top/images/2020/03/31/springDemo1.jpg)](https://pic.tyzhang.top/image/r5E)

然后使用spring进行依赖注入进行构建Car对象。  

[![springDemo2.jpg](https://pic.tyzhang.top/images/2020/03/31/springDemo2.jpg)](https://pic.tyzhang.top/image/svx)

[![springDemo3.jpg](https://pic.tyzhang.top/images/2020/03/31/springDemo3.jpg)](https://pic.tyzhang.top/image/WIj)

上图就说明了，借助于spring可以不需要知道内部的实现细节，这样的好处对于协作开发和项目的维护有很多大的帮助，其他程序员只需要使用接口即可，不需要知道内部的细节，对于 后来的维护也是很方便，核心代码可以一直稳定的运行，即依赖关系不会有大的变动，细节可以随意更改，而DI就是解决内部的依赖问题，需要有程序员去指定。  

## 一、Spring基础知识IOC和AOP

### IOC（控制反转）
中文名叫做控制反转，主要就是实现动态代理这个的东西，**为的就是将创建对象交给spring**，即代替程序员使用new关键字进行新建对象，然后使用工厂的模式和动态代理的方式进行创建对象。

总共有两种方式进行实现，**配置方式**和**注解方式** （主要的使用方式）

在进行ioc的时候，免不得出现需要属性注入的操作，也就是怎么讲变量的值或者是一个对象传递过去，这种操作较**DI**也即是依赖注入。 主要也就是对象的注入，因为这样的话就是可以实现两个对象之间的耦合，实现数据的传输。

#### IOC和DI的区别

- IOC：控制反转，把对象创建交给spring进行配置
- DI：依赖注入，向对象里面的属性进行设置值
- 关系：依赖注入不能够单独的存在，需要在ioc的基础上完成操作。

### AOP（面向切面）
主要的作用是为了实现（目前的认知）：就是记录某个方法的运行状态，或者是增强某个方法。但是这个的方式现在还是不是很熟悉。  

aop常用的是在数据库编程中，也就是事务的编写，主要解决的问题就是当一个请求需要多个部门进行审核的时候，请求在某个部分不被通过，那么就直接被驳回？ 但是这个aop又有什么关系？

aop的意思，有点像是可以实现程序在运行的过程中，通过设置切点可以直接获取此时程序进行运行的转态，或者是进行动态的添加代码进行运行，这样就可以在不进行更改代码的情况下实现代码的功能的扩展。其中，进行记录日志就是最典型的例子。即在程序在进行运行的时候，扩展记录操作。


## 二、IOC的实现方式

### 使用配置的方式进行注入

```xml
<!-- ioc 入门配置-->
<!-- 其中id就是新建的用户名， class 就是类的绝对路径 scope="prototype" 这个表示新建的实例是多实例，不加的话默认是单实例，即每次调用的都是同一个对象-->
<bean id = "book" class="ioc.Book"></bean>
<!--测试注入的方法  都必须定义属性然后设置set方法。-->
<bean id="user" class="ioc.User">
    <!--1 进行属性的注入 -->
    <property name="userName" value="小红" ></property>
    <!--2 进行对象的注入 -->
    <property name="book" ref="book"></property>
</bean>
```

首先bean标签表示新建一个对象， property标签表示调用的set方法进行的属性的注入。这种方式就是表示，所有的类都是可以通过这种方式进行进行对象的创建。包括jar包中的类。

### 常用的注解

#### 在类上使用的注解，表示这个类由spring进行构建

- `@Component`  最基础的
- `@Controller`  WEB层
- `@Service` 业务层
- `@Repository` 持久层

以上四个注解都是表示将类交给spring进行 处理，虽然名称不一致，但是作用是一致的，不同的名字表示这个对象是用在哪一个层，是的对象更好的分类

####  进行注入的注解

- `@Autowired` 表示自动的注入

### 例子测试

以下为注解的方式进行测试spring代码。测试平台为idea，新建spring项目即可。  

测试的主要目的就是通过autowired的方法进行依赖注入，即在user中实现注入book对象， 并且调用book对象的方法，实现具体的操作，这个简单的列子也就是说明，在controller中使用自动注入的方进行掉用调用service层的对象。  

总共有四个文件 user.java  book.java  bean.xml  test.java，其中user对象中进行注入book对象。

```java
User.java
@Component(value = "user")
public class User {

    //自动注入 只需要将对象创建好就行。
    @Autowired
    public Book book;

    public void add(){
        System.out.println("add.....");
        book.add();
    }
}

Book.java
@Component("book")
public class Book {
    public void  add(){
        System.out.println("book add...");
    }
}
```

```xml
// 这个主要需要注意的就是依赖的引用。即bean依赖和context依赖。
<?xml version="1.0" encoding="UTF-8"?>
<!--schema 约束-->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd

       http://www.springframework.org/schema/context      
       http://www.springframework.org/schema/context/spring-context.xsd ">

    <!-- ioc 入门配置-->
    <!--实现注释的方式进行spring配置-->
    <!--开启扫描 base 表示扫描iocContext 包-->
    <context:component-scan base-package="iocContext"></context:component-scan>

</beans>
```

最后是测试Test.java的。需要做的主要有加载xml文件获取spring构建的对象。

```java
package iocContext;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * @author Seven
 * @description 进行测试用户的案例
 * @create 2019-10-13 19:04
 **/

public class TestContext {
    @Test
    public void Test(){

        // 1 加载spring配置文件，根据其创建对象
        ApplicationContext context = new ClassPathXmlApplicationContext("beanContext.xml");

        // 2 得到配置创建的对象  不需要使用new关键字
        User user = (User) context.getBean("user");

        // 3 调用spring 自动生成的对象，然后进行调用。
        System.out.println(user);
        user.add();
 
    }
}
```

最后可以很好的输出结果。即不需要进行new，即可以实现调用需要对象的方法，即将对象统一交给spring进行管理。

![](/image/spring_run_result.png)

以上会有一个小问题，就是在spring项目中，这个项目的入口在哪里？就是最初的调用时在哪里实现的？需要对autoConfig类进行仔细的查看。
