---
layout: post
title: java虚拟机总结
tags: java  
---


> 介绍JVM的基础知识，备份学习

##  目录
* 目录
{:toc}
#  0.说明

本文JVM[从入门到精通的视频学习笔记](https://www.bilibili.com/video/BV1BJ41177cp?p=64) ，讲的比较好可以看看，但是还没有更新完， 所以没有讲完的部分还没有更新。

# 1.JVM整体结构

![jvmModel.png](https://pic.tyzhang.top/images/2020/03/28/jvmModel.png)

整个jvm的运行流程图如上所示，首先需要进行加载class文件，然后使用类加载子系统将class翻译解析导入内存，在内存中分别导入到对应的运行时数据区，然后执行引擎开始执行，对于需要的数据在对应的区域进行获取。  

另外本章所讲的都是基于Hotspot虚拟机，它采用的是**解释器与即使编译器(JIT)并存的架构。**  

**整体的结构说明：**

1. 类加载子系统：主要将class文件导入数据内存
2. 运行时数据区：提供程序运行所需要的所有数据，保存运行时产生的临时数据
3. 执行引擎：具体的执行执行的执行
4. 本地方法接口:第三方的扩展

**JVM架构模型依据**  

java编译器输入的指令流基本上是基于栈的指令集架构，其特点为：

1. 设计和实现简单，适用于资源受限的系统。
2. 避开了寄存器的分配难题，使用零地址指令方式分配。
3. 指令流中的指令大部分是零指令地址，其执行过程依赖于操作栈，指令集更小，编译器更容易实现。
4. 不需要硬件支持，可移植性更好，更好实现跨平台。

# 2.类加载子系统

类加载子系统的主要功能是将本地物理文件加载到内存中，其结构如下所示：

![ClassLoader.png](https://pic.tyzhang.top/images/2020/03/28/ClassLoader.png)

## 2.1 加载(Loading)  

1. 通过一个类的全限定名获取定义此类的二进制文件字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

## 2.2 类加载器的分类

1. JVM支持两种类型的加载器，分别为引导类加载器(BootStrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)。
2. 从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是java虚拟机规范没有这样定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。
3. 主要作用就是将java运行所需要的文件整合起来加载到内存。因为java在运行的时候需要很多额外的class支撑。

### 2.2.1 引导类加载器(BootStap ClassLoader)

1. 使用c/c++编写，嵌套在jvm内部。
2. 主要加载java核心库，如sun.boot.class.path路径下的内容，用于提供jvm自身需要的类。
3. 不继承java.lang.ClassLoader，没有父加载器。
4. 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
5. 处于安全考虑，只加载包为java、javax、sun等开头的包。

### 2.2.2 扩展类加载器(Extension ClassLoader)  

1. java语言编写，由sun.misc.lanucher$ExtClassLoader实现。
2. 派生于ClassLoader类。
3. 父类加载器为引导类加载器。
4. 从java.ext.dirs系统属性指定的目录加载，或.jre/lib/ext子目录，

### 2.2.3 系统类加载器(System ClassLoader)  

1. 加载用户自己写的类。

### 2.2.4 自定义类加载器(User Defined ClassLoader)  

为什么需要？  

1. 隔离加载类
2. 修改类加载方式
3. 扩展加载源
4. 防止源码泄露

### 2.2.5 双亲委派机制  

java虚拟机对class文件采用的是**按需加载**的方式，也就是说当需要该类时才会将它的class文件加载到内存中生成class对象，而且加载某个类的class文件时，java虚拟机采用的是**双亲委派机制**，即把请求交给父类去处理，父类能够处理就让父类处理，在父类处理不了以后，将任务交给子类，让子类尝试处理，直到任务处理。

![parent.png](https://pic.tyzhang.top/images/2020/03/28/parent.png)

**优势**  

1. 避免类的重复加载。
2. 保护程序的安全，防止核心api随意被修改。

jvm判断两个class对象是否为同一个类生成的两个必要条件：  

1. 类的完整类名必须一致，包括包名。
2. 加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。

另外，jvm必须知道一个类型是由启动加载器加载的还是由用户类加载加载的，如果一个类型是由用户类加载器加载，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中，当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的。  

## 2.3 验证(Verify)

1. 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被夹在类的正确性，不会危害虚拟机自身安全
2. 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。

## 2.4 准备(Prepare) 

1. 为类变量分配内存并且设置该类变量的默认初始值，即零值。
2. 这里不包括用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示的初始化。
3. 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。

## 2.5 初始化(Initialization)

1. 初始化阶段就是执行类构造器方法\<clinit>()的过程。
2. 此方法不需要定义，是javac编译器自动收集类中的所有**变量的赋值动作**和**静态代码块中的语句**合并而来。
3. 构造器方法中指令按语句在源文件中出现的顺序执行。
4. \<clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的\<init>()）。
5. 若该类具有父类，JVM会保证子类的\<clinit>()执行前，父类的\<clinit>()已经执行完毕.
6. 虚拟机必须保证一个类的\<clinit>()方法在多线程下被同步加锁。

# 3.运行时数据区

![runtimeDatArea.png](https://pic.tyzhang.top/images/2020/03/28/runtimeDatArea.png)

如上图所示，其中相同灰色为线程私有，绿色为多个线程共享的。  

线程是一个程序里的运行单元，jvm允许一个应用有多个线程并行执行，即多线程思想。另外，在hotpotJVM里，每个线程都与操作系统的本地线程直接映射，即同时创建和销毁。操作系统负责将所有的线程安排到任何一个可用的CPU上，一旦本地线程初始化成功，他就会调用Java线程中的run()方法。

## 3.1 程序计数器(PC Register)

这里的计数器(Program Counter Register)并非为广义上所指的物理寄存器，JVM中的PC寄存器（程序计数器）是对物理PC寄存器的一种抽象模拟。相当于IDE中的光标索引值，行号，表示当前正在编辑的行号。    

PC寄存器用来存储指向下一条指令的地址，也就是即将执行的指令代码，由执行引擎读取下一条指令。  

1. 它是一块很小的内存空间，几乎可以忽略不记，他也是运行速度最快的存储区域。
2. 在JVM规范中，**每个线程都有自己的程序计数器**，是线程私有的，生命周期与线程周期保持一致。
3. 任何时间一个线程都只有一个方法在执行，也就是所说的当前方法，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。或者，如果是在执行native方法，则是未指定值(undefined)
4. 他是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都是需要依赖这个计数器来完成。
5. 字节码解释器工作时就是通过更改这个计数器的值来选取下一条需要执行的字节码指令。
6. 他是**唯一一个**在Java虚拟机规范中没有任何OutOfMomeryError (OOM)情况的区域。
7. 其实就是相当于一个索引。

**问**：使用PC寄存器存储字节码指令地址有什么用？  

因为CPU需要不停的切换各个线程，当切换回来的时候，需要知道从哪里接着执行。JVM的字节码解释器就需要通过更改PC寄存器的值来说明下一条应该执行什么样的字节码指令。  

**问**：PC寄存器为什么会被设置为线程私有？  

因为CPU在进行执行程序的时候，是并发执行，即虽然有多个线程同时执行，但是CPU在一个特定的时间段内只会执行其中某一个线程的方法，即CPU在不停的切换任务，这样便会产生中断和恢复，为了能够准确记录各个线程正在执行的当前字节码指令地址，最好的办法就是**为每一个线程都分配一个PC寄存器，这样便能够每个线程之间独立的运行而不会出现干扰**。  

ps: 并行与并发？  

并行vs串行，即串行一个接一个执行，并行同时执行。  

并发：不断的切换，同时执行，但是每次只有一个在执行。  

## 3.2 java栈/虚拟机栈( Java Stack) 基础知识

虚拟机栈即是**程序运行时的单位**，而堆是**数据存储的单位**。  

**换句话说，栈解决的是程序运行的问题，即程序如何执行，如何处理数据，而堆是解决数据的存储问题，数据存在哪，放在哪。**

虚拟机栈细节如下图所示。其中当前栈帧中包含 **局部变量表**、**操作数栈**、**动态链接**、**本地返回值**。  

![pcCount.png](https://pic.tyzhang.top/images/2020/03/28/pcCount.png)

另外对于栈来说，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，栈帧则对应着一次次的java方法调用。例如递归的调用。  

主管java程序的运行，保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果、参与方法的调用和返回。 

### 3.2.1 栈的特点

栈是一种快速有效的分配存储方式，其访问速度仅仅次于程序计数器。  

JVM直接对Java栈的操作比较单一，只有两个：

1. 每个方法执行，伴随着进栈
2. 执行结束后出栈工作

另外，对于栈来说，不存在垃圾回收问题。  

### 3.2.2 栈可能出现的异常

JVM允许java栈的大小是动态的或者是固定不变的。

1. 如果采用固定的栈，超过会报出StackOverFlowError
2. 如果是动态的，动态即可以申请到内存中剩余的空间，如果空间不足则爆出OutOfMemoryError

### 3.2.3 栈的存储单位

1. 每个线程都有自己的栈，栈中的数据都是以栈帧(Stack Frame)的格式存在。
2. 每个线程上正在执行的**方法**都对应一个栈帧。注意是一个函数方法对应一个栈帧。
3. 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据结果，不能和平时使用的那种栈相比较，平时使用的是数据区太小。现在是一个操作步骤组成的栈帧。
4. 对于递归来说，递归一次就相当于新建一个栈帧。上图中也表示，栈帧中保存着很多数据。

### 3.2.4 栈的运行原理

1. JVM直接对Java栈的操作只有两个，就是对栈帧的**压栈**和**出栈**，并且遵循先进后出，后进先出的原则。
2. 在一条活动的线程中，一个时间点上，只有一个活动的栈帧，即只有当前在执行的方法的栈帧（顶部栈帧）是有效的，这个栈帧被称之为当前栈帧(Current Frame)，与当前栈帧对应的方法就是当前方法(Current Method)，定义这个方法的类就是当前类(Current Class)。
3. 执行引擎运行的所有字节码指令只针对当前帧进行操作。
4. 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。
5. **不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧**。
6. 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧冲洗成为当前栈帧。
7. java方法有两种返回函数的方式，一种是**正常的函数返回**，使用return指令，另外一种是**抛出异常**，不管使用哪种方式，都会导致栈帧被弹出。

运行图示如下：首先是一个方法对应一个栈帧，当方法1调用方法2的时候，会将方法2入栈，然后方法三入栈，最后到了方法4，当方法4执行完成后，顺序返回，最终到方法1收到结果。运行结束。

[![Stack.png](https://pic.tyzhang.top/images/2020/03/30/Stack.png)](https://pic.tyzhang.top/image/pbK)

一个简单的调用demo  

```java
 public class CurrentFrameTest{
        
        public void methodA(){
            System.out.println("当前栈帧对应方法->methodA");
            methodB();
            System.out.println("当前栈帧对应方法->methodA");
        }
        
        public void methodB(){
            System.out.println("当前栈帧对应方法->methodB");
        }
    }
```

## 3.3 栈帧的内部结构

每个栈帧中存着：

1. **局部变量表(Local Variables)**
2. **操作数栈(Opreand Stack) 或表达式栈**
3. 动态链接 (Dynamic Linking) （或指向运行时常量的方法引用）
4. 动态返回地址(Return Address) （或方法正常退出或者异常退出的引用的定义）
5. 一些附加信息

[![stackinner.png](https://pic.tyzhang.top/images/2020/03/30/stackinner.png)](https://pic.tyzhang.top/image/uHf)

### 3.3.1 局部变量表

1. 局部变量表也被称之为局部变量数据组或本地变量表。
2. 定义为一个数字数组，主要用户存储**方法参数**和定义在**方法体内的局部变量**，这些数据类型包括各类基本数据类型、对象引用(reference)，以及returnAddress 类型。
3. 由于局部变量表示建立在线程的栈上，是线程的私有数据，因此不存在数**据安全问题**。
4. **局部变量表所需要的容量大小是在编译期确定下来的**，并保存在方法的Code属性的maximun local variables数据项中，在方法运行期间时不会改变局部变量表的大小的。
5. **方法嵌套调用的次数由栈的大小决定**，一般来说，**栈越大，方法嵌套调用次数越多**，对于一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈就越大，以满足方法调用所需传递的信息增大的需求，进而函数调用就会占更多的栈空间，导致其嵌套调用次数就会减少。
6. **局部变量表中的变量只在当前方法调用中有效**。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程，当**方法调用结束后，随着方法栈的销毁，局部变量表也会随之销毁**。

### 3.3.2 局部变量表存储单元Slot

1. 参数值的存放总是在局部变量数据的index0开始，到数组长度-1的索引结束。
2. 局部变量表，最基本的存储单元是Slot（变量槽）。
3. 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型(reference),returnAdderss类型的变量。
4. 在局部变量表中，32位以内的类型只占一个slot（包括returnAdderss类型）64位的类型(long和double)占用两个slot。
   1. byte、short、char在存储前被转换为int，boolean也被准换为int，0为false，1为true。
   2. long和double则占据两个slot。
5. JVM会为局部变量表中的每一个slot都分配**一个访问索引**，通过这个索引即可成功的访问到局部变量表中指定的局部变量值。
6. 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量表将会按照顺序被复制到局部变量表中的每一个slot上。
7. 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。
8. 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会被存放在index为0的slot处，其余的参数按照参数表顺序继续排列。

[![variables.png](https://pic.tyzhang.top/images/2020/03/30/variables.png)](https://pic.tyzhang.top/image/4yM)

一个问题：为什么static中不能调用this方法？   

因为this的索引只存在构造方法和实例方法的局部变量表中，而static是在初始化方法\<clinit>中进行初始化的,里面没有保存this变量的索引。实例方法即为自己定义的非静态方法。    

另外，slot也是可以进行重复利用的，即如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期的局部变量的槽位，从而达到节约资源的目的。主要的运用方式如下所示，其中{}连的用完作用域就结束了。  

```java
 public void LocalVar(){
            {
                int a= 0;
                System.out.println(a);
            }
            //此时b就会复用a的槽位
            int b=0;
        }
```

### 3.3.3 局部变量表补充说明

静态变量与局部变量的对比：  

1. 参数表分配完毕以后，在根据方法体内定义的变量的顺序和作用域分配。
2. 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次是在“初始化”阶段，赋予程序员在代码中定义的初始值。
3. 和类变量初始化不同的是，局部变量表不存在系统初始化过程中，这就意味着一旦定了局部变量则必须认为的初始化，否则无法使用。

```java
public void test(){
    int i;
    Systme.out.println(i);
    //这种是编译不通过的。
}
```

ps：变量的分类：  

1. 按照数据类型分类
   1. 基本数据类型
   2. 引用数据类型(对象)
2. 按照在类中的位置分
   1. 成员变量：类中变量，在使用前，都经历默认初始化赋值。
      1. 类变量，Linking的prepare阶段，给类变量默认赋值-->initial阶段，给类变量显示赋值，即静态代码块赋值。
      2. 实例变量，随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值。
   2. 局部变量：方法中的变量。在使用时必须进行显示的赋值，否则编译不通过。

补充说明：  

1. 在栈帧中，**与性能调优关系最为密切的部分就是前面提到的局部变量表**，在方法执行时，虚拟机使用局部变量表完成方法的传递。
2. 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中的直接或者间接引用的对象都不会被回收。
3. 也可以新建局部对象。

## 3.4 操作数栈(Opreand Stack)

它是由数组实现的，保存数据的一个栈。  

1. 每个独立的栈帧除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack)。
2. 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或是提取数据，即入栈(push)和出栈(pop)。
   1. 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用它们后再把结果压入栈。
   2. 比如：执行复制、交换、求和等操作。
3. 操作数栈，**主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间**。
4. 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。
5. 每一个操作数栈都会拥有**一个明确的栈深度用户存储数值，其所需的最大深度在编译期就定义好了**，保存在方法的Code属性中，为max-stack的值。（因为伴随着出栈和入栈，所以只需一定的深度便能够满足所有的操作）。
6. 栈的任何一个元素都是可以任意的Java数据类型。
   1. 32bit的类型占用一个栈单位深度
   2. 64bit的类型占用两个栈单位深度
7. 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一个数据的访问。
8. 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。
9. 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要在次验证。
10. 另外，我们说的java虚拟机的解释引擎是基于栈的执行引擎，其中的栈值的就是操作数栈。

缺点：  

前面提到过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但是完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读、写次数。  

而且由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行的速度，为了解决这个问题，HotSpot JVM的设计者们提出了栈**顶缓存**（TOS TOP-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低内存的读/写次数，提升执行引擎的执行效率。  

## 3.5 动态链接（或指向运行时常量池的方法引用）

整体的链接流程图：其主要就是**指向运行时常量池的方法引用**  

[![dynamicLinking.png](https://pic.tyzhang.top/images/2020/03/30/dynamicLinking.png)](https://pic.tyzhang.top/image/nd4)

1. 每一个栈帧内存都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。比如invokedynamic 指令。
2. 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference )保存在class文件的常量池里。比如，描述一个方法调用其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

为什么需要常量池？  

常量池的作用就是为了提供一些符号和常量，便于指令的识别。  

### 3.5.1 方法的调用

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。

**静态链接：**  

当一个字节码文件被装在进JVM内存时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接而引用的过程称之为静态链接。  例如，super()方法。

**动态链接：**  

如果被调用的方法无法在编译期确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程中具备动态性，因此也被称之为动态链接。对应着接口回调，多态动态绑定等。  

与之对应的则是方法的绑定机制。早期绑定(Early Binding)和晚期绑定(late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这里仅仅发生一次。  

**早期绑定:**  

早期绑定就是被调用的目标函数如果在编译期可知，且运行期间保持不变，即可将这个方法与所属的类型进行绑定。  

**晚期绑定：**  

如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型半丁相关的方法，被称之为晚期绑定。其实也就是动态绑定。。  

### 3.5.2 非虚方法

1. 对应着进行早期绑定和静态链接的定义，即在编译期就确定了具体的调用版本，在运行时不可变，称之为非虚方法。
2. 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
3. 其他方法称之为虚方法。
4. 子类对象的多态性使用的前提为：类的继承关系，方法的重写。

### 3.5.3 方法的调用；虚方法与非虚方法

虚拟机中提供了一下几条方法调用指令：  

普通调用指令：  

1. invokestatic；调用静态方法，解析阶段确定唯一方法版本。
2. invokesopecial;调用\<init>方法、私有即父类犯法，解析阶段确定唯一方法版本。
3. invokevirtual:调用所有虚方法。
4. invokeinterface：调用接口方法。

动态调用指令:  

5. invokedynamic：动态解析出所有需要的方法，然后执行，(lamble表达式)，和python一样，变量不需要自己执行，运行时才知道。

### 3.5.4 方法的调用：方法重写的本质

1. 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
2. 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则放回这个方法的直接引用，查找过程结束；如果不通过，则返回，java.lang.illegalAccessError异常。
3. 否则，按照继承关系从上往下依次对C的各个父类进行第2步的搜索和验证过程。
4. 如果始终没有找到合适的方法，则抛出java.lang.AbstactMethodError异常。

### 3.5.5 方法的调用；虚方法表

可以简单的理解为自己写的方法就是虚方法。

1. 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话可能影响到执行效率，因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表(virtual method table)(非虚方法不会出现在表中)来实现，使用索引表来替代查找。
2. 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。

虚方法表在什么时候被创建？  

虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成以后，JVM会把该类的方法表也初始化完毕。    

### 3.5.6 方法返回地址(return address)

1. 存放该调用方法的pc寄存器的值。
2. 一个方法的结束，有两种方式：
   1. 正常的执行完成
   2. 出现异常，非正常退出
3. 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址，而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
4. 本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的数据区等信息，让调用者方法继续执行下去。
5. 正常完成出口和异常完成出口的区别在于，通过异常完成出口推出的不会给他的上层调用者产生任何的返回值。

但一个方法开始执行后，只有两种方式可以退出这个方法。

1. 遇到return，将返回值传递给上层方法调用者，简称正常完成出口。
   1. 返回指令包括ireturn(返回值为boolean,byte,char,short,int),lreturn,freturn,dreturn,以及areturn，还有return 返回为void、实例初始化方法，类和接口的初始化方法。
2. 异常完成出口，即碰到了异常，并且没有在方法内进行处理，就会退出方法。方法在执行过程总抛出异常时的异常处理，储存在一个异常处理表，方法在发生异常时候找到处理异常的代码。

## 3.6 本地方法(native method)

本地其实就是第三方接口，调用非java代码的接口。在java刚出来的时候为了兼容c和c++语言，即java可以调用c或c++程序，另外因为java要和操作系统交互，所以有些方法必须要使用c进行实现，比如线程的映射。

### 3.6.1 本地方法栈

java虚拟机栈用于管理java方法的调用，而本地方法栈用于管理本地方法的调用。

1. 本地方法栈也是线程私有的。
2. 允许被实现成固定或者是动态可扩展的内存大小。 
3. 本地方法是使用c实现
4. 他的具体做法是native method stack中登记native方法，在execution engine 执行时加载本地方法库
5. 当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界，他和虚拟机拥有同样的权限
6. 并不是全部的虚拟机都支持本地方法
7. 在hotspot中，直接将本地方法栈和虚拟机栈合二为一。



未完待续~。



