<!DOCTYPE html>
<html lang="en">

  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#546E7A">

    

    <title>RPC：实现原理与学习</title>

    
      
    

    <link rel="canonical" href="www.diaowenjie.cn/2020/05/20/java-rpc.html">

    
    <meta name="keywords" itemprop="keywords" content="blog,css,html,php">
    <link rel="shortcut icon" sizes="128x128" href="/avatar/favicon.png">

    <meta name="robots" content="noarchive">

   
    <style>
.site-header {
   background-color: #546E7A;
   }
.page-header {
   background: url("https://api.dujin.org/bing/1920.php") no-repeat center; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size:cover; max-width:100%; margin: auto;text-align: center;margin-bottom:20px;
}
</style>

    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/fade.css">
    <meta name="google-site-verification" content="tb5-LFfZ4ccQdqYC0-JKdEi3uWBF3IFo8PNsDcahigs" />
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">刁文杰的博客</a>
    

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#ffffff" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#ffffff" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#ffffff" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
              
                <a class="page-link" href="/Billboard.html">Billboard</a>
              
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
              
                <a class="page-link" href="/archives.html">Archives</a>
              
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/links.html">Links</a>
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/pages/tags.html">Tags</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    
    
    <script>
      var OriginTitile = document.title;
      var titleTime;
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          document.title = '刁文杰的博客 ' + OriginTitile;
          clearTimeout(titleTime);
        }
        else {
          document.title = '刁文杰的博客 ' + OriginTitile;
          titleTime = setTimeout(function() {
            document.title = OriginTitile;
          }, 2000);
        }});

    </script>

    <section class="page-header">
      <h1 class="project-name">RPC：实现原理与学习</h1>
      <h2 class="project-tagline"></h2>
      
        <h2 class="project-date">
        <time datetime="2020-05-20T00:00:00+08:00" itemprop="datePublished">
          
          May 20, 2020
        </time>
        
        
          • <span itemprop="author" itemscope itemtype=""><span itemprop="name">刁文杰的博客</span></span>
        
        </h2>
      
    </section>

    <section class="main-content fade">

      <article itemscope itemtype="">

  <header class="post-header">
      <link rel="dns-prefetch" href="//cdn.bootcss.com" />
    <h1 class="post-title" itemprop="name headline">RPC：实现原理与学习</h1>
    <p class="post-meta">
      <time datetime="2020-05-20T00:00:00+08:00" itemprop="datePublished">
        
        May 20, 2020
      </time>
      </p>
  </header>
<script type="text/javascript" async
src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  document.getElementsByTagName("img").className="bbb";  
  </script>
  
  <div itemprop="articleBody">
    <blockquote>
  <p>记录rpc项目的实现方式与底层原理。</p>
</blockquote>

<h2 id="目录">目录</h2>
<ul id="markdown-toc">
  <li><a href="#目录" id="markdown-toc-目录">目录</a></li>
  <li><a href="#前言" id="markdown-toc-前言">前言</a></li>
  <li><a href="#代码实现" id="markdown-toc-代码实现">代码实现</a>    <ul>
      <li><a href="#服务器端" id="markdown-toc-服务器端">服务器端</a></li>
      <li><a href="#客户端" id="markdown-toc-客户端">客户端</a></li>
      <li><a href="#http与rpc之间的关系" id="markdown-toc-http与rpc之间的关系">HTTP与RPC之间的关系</a></li>
    </ul>
  </li>
</ul>
<h1 id="前言">前言</h1>

<p>RPC(Remote Procedure Call):远程过程调用，即一台机器调用另一台机器上的方法，主要用于服务器集群之间的代码调用。之前写代码都是在自己电脑上跑，如果有数据交互也就是线程之间的交互，但是现在随着服务的扩大，很多代码已经不能再一个电脑上跑了，出现一台电脑需要调用另一台电脑上代码方法的情况。此时提出来的框架就是rpc技术，它可以实现电脑A像调用自己内存中的方法一样调用电脑B内存中的方法，这样也就实现了集群的开发，即从之前的线程之间的通信变成了服务器之间的代码交互。</p>

<p>目前，Java界的RPC中间件百家争鸣，国内开源的就有阿里的Dubbo(当当二次开发的DubboX)，新浪Motan；国外跨语言的有Facebook的Thrift， Google的gRPC等。</p>

<p>以上的说明需要解决的问题有两个：<strong>方法参数的编码</strong>，<strong>电脑A与电脑B之间数据的传输</strong>。对于方法中的参数来说，使用的就是java的序列化与反序列化(Serializable)，因为很多时候传递的参数都是一个类，那么就需要进行编码。数据的传输就涉及到java的网络编程，现阶段大多使用的就是基于socket的netty框架进行数据的传输。另外还有一个问题就是，服务器集群就意味着会有很多的方法可以被调用，那么如果有效的找到自己需要的方法在哪里？此时使用的技术就是服务发现，其实现的思想有点类似于DNS，即通过一个服务器管理所有的服务接口，通过服务器来指导服务之间的调用，此时使用的技术就是zookeeper服务器进行管理。</p>

<p><img src="https://pic.tyzhang.top/images/2020/05/23/rpc.png" alt="rpc.png" /></p>

<p>更加详细的流程实现：</p>

<p><img src="https://pic.tyzhang.top/images/2020/07/09/rpcStruct.png" alt="rpcStruct.png" /></p>

<h1 id="代码实现">代码实现</h1>

<p>一个基于Spring框架和Http协议的的rpc实现，<a href="https://github.com/yeecode/EasyRPC">参考代码</a> 初学阶段没有必要使用netty框架，本项目只是通过网络连接实现rpc。</p>

<p>对于rpc来说，其实现思想是：使用基于接口的动态代理技术将客户端的接口进行实现，类比于mybatis使用xml自动实现dao实现类，rpc是使用网络传输实现接口的实现类，具体表现为，在进行动态代理时，调用网络服务，动态代理方法将网络返回值返回。如下所示，主要有三个过程，代码如下。</p>

<ol>
  <li>获取方法参数<strong>(参数序列化)</strong></li>
  <li>进行<strong>网络连接</strong>，将服务器端方法名和参数传递过去</li>
  <li>将返回的结果作为执行结果返回<strong>(结果反序列化)</strong></li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 服务代理类，使用反射将调用的service进行实现，实现的方法为使用socket调用服务器端方法。
 * @param &lt;T&gt;
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceProxy</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">InvocationHandler</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="no">T</span> <span class="n">target</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ServiceProxy</span><span class="o">(</span><span class="no">T</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     *  实现动态代理 ，即通过调用远程的方法，作为接口类的实现类。
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="c1">//1.获取参数</span>
        <span class="nc">RemoteClass</span> <span class="n">remoteClass</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getDeclaringClass</span><span class="o">().</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">RemoteClass</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">remoteClass</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"远程类标志未指定"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">argTypeList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">args</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span> <span class="o">:</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">argTypeList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
		<span class="c1">//2.进行网络连接</span>
        <span class="nc">String</span> <span class="n">argTypes</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">argTypeList</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">argValues</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
        <span class="c1">//使用socket 进行调用远程的service方法，remoteClass 表示对应的对象的全类名。</span>
        <span class="c1">// 并且将参数传递过去。Http表示为网络连接工具类。</span>
        <span class="nc">Result</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">HttpUtil</span><span class="o">.</span><span class="na">callRemoteService</span><span class="o">(</span><span class="n">remoteClass</span><span class="o">.</span><span class="na">value</span><span class="o">(),</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">argTypes</span><span class="o">,</span> <span class="n">argValues</span><span class="o">);</span>
		
        <span class="c1">//3. 将网络连接的结果返回，作为该接口的执行结果，变相作为接口的实现类。</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">isSuccess</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="no">JSON</span><span class="o">.</span><span class="na">parseObject</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getResultValue</span><span class="o">(),</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getResultType</span><span class="o">()));</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"远程调用异常："</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>另外因为要使用动态代理技术，所以实现rpc的前提是，客户端需要定义接口而服务端有该接口的实现类。</p>

<p>客户端: 其中RemoteClass为自定义注解。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RemoteClass</span><span class="o">(</span><span class="s">"com.github.yeecode.easyrpc.server.service.SchoolService"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SchoolService</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">querySchoolName</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@RemoteClass</span><span class="o">(</span><span class="s">"com.github.yeecode.easyrpc.server.service.UserService"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserService</span> <span class="o">{</span>

    <span class="nc">Integer</span> <span class="nf">getUserCount</span><span class="o">();</span>

    <span class="nc">String</span> <span class="nf">getUserInfo</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">id</span><span class="o">);</span>

    <span class="nc">Integer</span> <span class="nf">addUser</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">email</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">sex</span><span class="o">,</span> <span class="nc">String</span> <span class="n">schoolName</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>服务器端：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.github.yeecode.easyrpc.server.service</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SchoolService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">querySchoolName</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method querySchoolName called:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Arg id="</span> <span class="o">+</span> <span class="n">id</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"*************************"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"Sunny School"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">getUserCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method getUserCount called:"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"*************************"</span><span class="o">);</span>

        <span class="k">return</span> <span class="mi">18</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getUserInfo</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
      	
        <span class="c1">// 具体实现</span>
        <span class="k">return</span> <span class="s">"success"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">addUser</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">email</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">sex</span><span class="o">,</span> <span class="nc">String</span> <span class="n">schoolName</span><span class="o">)</span> <span class="o">{</span>
      	
        <span class="c1">//具体实现</span>
        <span class="k">return</span> <span class="mi">19</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>通过以上的映射关系，然后加上动态代理技术，便能够实现一个非常简单的rpc框架。但是还有很多的细节需要打磨。</p>

<h2 id="服务器端">服务器端</h2>

<p>主要需要监听网络连接请求并且处理连接，并且根据请求参数，反序列化生成对象，另外需要保持service对象为单例。</p>

<p>首先是监听请求的controller类。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainController</span> <span class="o">{</span>
    <span class="cm">/**
     * 获取客户端发送的请求，其中参数与发送端是保持一致的， 进行反序列请求参数，
     * @param identifier 全限定包名
     * @param methodName 方法名
     * @param argTypes  方法参数类型
     * @param argValues 方法参数值
     * @return 返回调用的结果
     */</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Result</span> <span class="nf">rpcMain</span><span class="o">(</span><span class="nc">String</span> <span class="n">identifier</span><span class="o">,</span> <span class="nc">String</span> <span class="n">methodName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">argTypes</span><span class="o">,</span> <span class="nc">String</span> <span class="n">argValues</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
			<span class="c1">//使用反射根据名称获取该对象class。</span>
            <span class="nc">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">identifier</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">clazz</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">Result</span><span class="o">.</span><span class="na">getFailResult</span><span class="o">(</span><span class="s">"目标类不存在"</span><span class="o">);</span>
            <span class="o">}</span>
            
            <span class="c1">// 获取参数类型 (String  Integer 等等)</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">argTypeList</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">.</span><span class="na">parseArray</span><span class="o">(</span><span class="n">argTypes</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Class</span><span class="o">&gt;</span> <span class="n">argClassList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">argType</span> <span class="o">:</span> <span class="n">argTypeList</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">argClassList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">argType</span><span class="o">));</span>
            <span class="o">}</span>
            
            <span class="c1">// ArrayList.toArray()方法，直接将List&lt;Object&gt; 转成 Object[] 数组，然后就可以直接的获取到里面的对象。</span>
            <span class="nc">Class</span><span class="o">[]</span> <span class="n">argClassArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Class</span><span class="o">[</span><span class="n">argClassList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
            <span class="n">argClassList</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">argClassArray</span><span class="o">);</span>
            <span class="c1">// 将argClassList转成 Class[] argClassArray数组的类型。</span>

            <span class="c1">// 获取参数值</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">argValueStringList</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">.</span><span class="na">parseArray</span><span class="o">(</span><span class="n">argValues</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">argValueList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argTypeList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">argClassList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">argValueList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">argValueStringList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">argValueList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="no">JSON</span><span class="o">.</span><span class="na">parseObject</span><span class="o">(</span><span class="n">argValueStringList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">argClassList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">argValueList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
            <span class="n">argValueList</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>

            <span class="c1">// 使用反射获取到类的成员方法  methodName 方法名  argClassArray 方法参数类型</span>
            <span class="nc">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="n">methodName</span><span class="o">,</span> <span class="n">argClassArray</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">Result</span><span class="o">.</span><span class="na">getFailResult</span><span class="o">(</span><span class="s">"目标方法不存在"</span><span class="o">);</span>
            <span class="o">}</span>
            
			<span class="c1">// 获取单例service对象。 其实也就是执行  Object obj = clazz.newInstance(); 此方法是为了保持获取单例service对象</span>
            <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="nc">ServiceGetter</span><span class="o">.</span><span class="na">getServiceByClazz</span><span class="o">(</span><span class="n">clazz</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">Result</span><span class="o">.</span><span class="na">getFailResult</span><span class="o">(</span><span class="s">"目标类的实例无法生成"</span><span class="o">);</span>
            <span class="o">}</span>
            
            <span class="c1">//使用反射调执行方法，obj为对应的类，args为方法参数值。</span>
            <span class="c1">// 返回的结果为object对象，所以不用知道对应的返回类型是什么。</span>
            <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
            <span class="k">return</span> <span class="nc">Result</span><span class="o">.</span><span class="na">getSuccessResult</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="no">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ex</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="k">return</span> <span class="nc">Result</span><span class="o">.</span><span class="na">getFailResult</span><span class="o">(</span><span class="s">"服务端解析异常"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>另外在获取service的对象时，<code class="language-plaintext highlighter-rouge">Object obj = ServiceGetter.getServiceByClazz(clazz);</code>，采用的是单例模型，即如果Map中有则直接的获取，否则新建一个放进Map容器中并返回。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">getServiceByClazz</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//Map中是否有</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">serviceMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">clazz</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">serviceMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">clazz</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//没有就进行新建。</span>
            <span class="no">T</span> <span class="n">bean</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
            <span class="n">serviceMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">bean</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ex</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>以上便是服务器端的实现，整体来说比较简单，因为是简单的demo，所以没有用zookeeper进行服务的注册的发现，在此不表。</p>

<h2 id="客户端">客户端</h2>

<p>客户端的实现比较复杂一点，他的主要测试方法是通过访问客户端定义的接口，然后客户端将请求进行转发，其接口的实现使用服务器端的实现类。首先是自定义一个注解，因为注解只是一个标记，并且可以获取到注解里面的值，所以很适合获取到该接口对应的服务器实现类的全类名。其实这样就说明了，这种实现方法并不是很自动，也是需要双方知此知彼，并不是什么都不知道，类似于url，实现方式如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 自定义注解， 获得调用的远端包名。
 */</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">RemoteClass</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span>

</code></pre></div></div>

<p>而为什么要使用注解，是因为要用到动态代理，而在java中只有使用动态代理的时候才能够获取到注解里面的值，即真正发挥注解的作用。</p>

<p>使用的方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//表示服务器端的具体实现类的全类名</span>
<span class="nd">@RemoteClass</span><span class="o">(</span><span class="s">"com.github.yeecode.easyrpc.server.service.SchoolService"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SchoolService</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">querySchoolName</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>经过以上的分析，现在只是知道了客户端与服务器端是怎么发生关系的。但是如何实现的呢？当用户通过访问客户端的url时，可以发现，初始的接口在与客户端的controller，如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 主要的客户端调用控制器。开发出来的接口。
 */</span>
<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainController</span> <span class="o">{</span>
    
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>
    
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">SchoolService</span> <span class="n">schoolService</span><span class="o">;</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/getUserCount"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getUserCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">userCount</span> <span class="o">=</span> <span class="n">userService</span><span class="o">.</span><span class="na">getUserCount</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">userCount</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/getUserInfo"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getUserInfo</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">userInfo</span> <span class="o">=</span> <span class="n">userService</span><span class="o">.</span><span class="na">getUserInfo</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">userInfo</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/addUser"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">addUser</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">userId</span> <span class="o">=</span> <span class="n">userService</span><span class="o">.</span><span class="na">addUser</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"abc@gmail.com"</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"Garden School"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">userId</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/querySchoolName"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">querySchoolName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">schoolService</span><span class="o">.</span><span class="na">querySchoolName</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以发现，是通过自动注入<code class="language-plaintext highlighter-rouge">UserService SchoolService</code>两个对象进行实现的，但是问题是在客户端这边这两个类都是接口，没有具体的实现对象，而具体的实现类是客户端通过网络连接调用服务器端的具体实现类进行实现的。那么就意味着，这接口的实现交给了spring进行维护。</p>

<p>经过分析发现，只有<code class="language-plaintext highlighter-rouge">ServiceBeanDefinitionRegistry</code>被标记为<code class="language-plaintext highlighter-rouge">@Component</code>，也就是说是通过这个类将接口的实现交给了spring进行维护。</p>

<p>前提知识:</p>

<p><code class="language-plaintext highlighter-rouge">BeanDefinitionRegistryPostProcessor</code>是<code class="language-plaintext highlighter-rouge">BeanFactoryPostProcessor</code>的扩展,它允许在<code class="language-plaintext highlighter-rouge">BeanFactoryPostProcessor</code>被调用之前对<code class="language-plaintext highlighter-rouge">BeanDefinition</code>做一些操作, 尤其是它可以注册<code class="language-plaintext highlighter-rouge">BeanFactoryPostProcessor</code>的<code class="language-plaintext highlighter-rouge">BeanDefinition</code>，它提供了一个方法<code class="language-plaintext highlighter-rouge">postProcessBeanDefinitionRegistry()</code>，这个方法被调用的时候，所有的<code class="language-plaintext highlighter-rouge">BeanDefinition</code>已经被加载了, 但是所有的Bean还没被创建。</p>

<p>以上主要说明的就是，通过这个类可以动态的向spring容器中添加对象，以下为<code class="language-plaintext highlighter-rouge">ServiceBeanDefinitionRegistry</code>的简略版</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceBeanDefinitionRegistry</span> <span class="kd">implements</span> <span class="nc">BeanDefinitionRegistryPostProcessor</span><span class="o">,</span> <span class="nc">ResourceLoaderAware</span><span class="o">,</span> <span class="nc">ApplicationContextAware</span> <span class="o">{</span>
    <span class="cm">/**
     *  主要的方法。使用下面自定义的扫描和注册方法。post表示在正常的bean注入完成以后，后面新加的也可以动态的注入到springioc容器中。
     *  这个方法来自 BeanDefinitionRegistryPostProcessor
     * @param registry
     * @throws BeansException
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postProcessBeanDefinitionRegistry</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
        <span class="c1">// 进行扫描包 需要添加进行ioc容器的路径。</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Class</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">clazzSet</span> <span class="o">=</span> <span class="n">scannerPackages</span><span class="o">(</span><span class="s">"com.github.yeecode.easyrpc.client.remoteservice"</span><span class="o">);</span>
        <span class="n">clazzSet</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="nl">Class:</span><span class="o">:</span><span class="n">isInterface</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">registerBean</span><span class="o">(</span><span class="n">registry</span><span class="o">,</span> <span class="n">x</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">registerBean</span><span class="o">(</span><span class="nc">BeanDefinitionRegistry</span> <span class="n">registry</span><span class="o">,</span> <span class="nc">Class</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BeanDefinitionBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="nc">BeanDefinitionBuilder</span><span class="o">.</span><span class="na">genericBeanDefinition</span><span class="o">(</span><span class="n">clazz</span><span class="o">);</span>
        <span class="nc">GenericBeanDefinition</span> <span class="n">definition</span> <span class="o">=</span> <span class="o">(</span><span class="nc">GenericBeanDefinition</span><span class="o">)</span> <span class="n">builder</span><span class="o">.</span><span class="na">getRawBeanDefinition</span><span class="o">();</span>
        <span class="n">definition</span><span class="o">.</span><span class="na">getConstructorArgumentValues</span><span class="o">().</span><span class="na">addGenericArgumentValue</span><span class="o">(</span><span class="n">clazz</span><span class="o">);</span>
        <span class="c1">// 调用ServiceFactory.class 将其注入到容器中</span>
        <span class="n">definition</span><span class="o">.</span><span class="na">setBeanClass</span><span class="o">(</span><span class="nc">ServiceFactory</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">definition</span><span class="o">.</span><span class="na">setAutowireMode</span><span class="o">(</span><span class="nc">GenericBeanDefinition</span><span class="o">.</span><span class="na">AUTOWIRE_BY_TYPE</span><span class="o">);</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">registerBeanDefinition</span><span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">(),</span> <span class="n">definition</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>其中<code class="language-plaintext highlighter-rouge">ApplicationContext</code>这个类，就是spring Ioc 容器的具体对象，即通过这个类控制整个ioc容器的实现，管理等操作。从上面可以看出，主要的就是先扫描需要实现的包，然后使用工厂类将对象注入到ioc容器中<code class="language-plaintext highlighter-rouge">definition.setBeanClass(ServiceFactory.class);</code>。</p>

<p>也就是说，我们需要的对象是通过<code class="language-plaintext highlighter-rouge">ServiceFactory</code>这个类进行构建并且添加到ioc容器中去的。那么下面来看看这个类。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 *  服务工厂类
 * @param &lt;T&gt;
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceFactory</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">FactoryBean</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">interfaceType</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ServiceFactory</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">interfaceType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">interfaceType</span> <span class="o">=</span> <span class="n">interfaceType</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">InvocationHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServiceProxy</span><span class="o">&lt;&gt;(</span><span class="n">interfaceType</span><span class="o">);</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">interfaceType</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span>
                <span class="k">new</span> <span class="nc">Class</span><span class="o">[]{</span><span class="n">interfaceType</span><span class="o">},</span> <span class="n">handler</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">getObjectType</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">interfaceType</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSingleton</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从上面可以看出主要就是调用<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance(interfaceType.getClassLoader(),new Class[]{interfaceType}, handler)</code>这个方法进行动态代理生成对象，其中最主要的方法就是handler对象，可以看出调用的是<code class="language-plaintext highlighter-rouge">new ServiceProxy&lt;&gt;(interfaceType)</code>这个对象。那么来看：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 服务代理类，使用反射将调用的service进行实现，实现的方法为使用socket调用服务器端方法。
 * @param &lt;T&gt;
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceProxy</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">InvocationHandler</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="no">T</span> <span class="n">target</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ServiceProxy</span><span class="o">(</span><span class="no">T</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     *  实现动态代理 ，即通过调用远程的方法，作为接口类的实现类。
     * @param proxy
     * @param method
     * @param args
     * @return
     * @throws Throwable
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="c1">//使用动态代理获取注解上面的内容。</span>
        <span class="nc">RemoteClass</span> <span class="n">remoteClass</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getDeclaringClass</span><span class="o">().</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">RemoteClass</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">remoteClass</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"远程类标志未指定"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">argTypeList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">args</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span> <span class="o">:</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">argTypeList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">String</span> <span class="n">argTypes</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">argTypeList</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">argValues</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
        <span class="c1">//使用socket 进行调用远程的service方法，remoteClass 表示对应的对象的全类名。</span>
        <span class="c1">// 并且将参数传递过去。</span>
        <span class="nc">Result</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">HttpUtil</span><span class="o">.</span><span class="na">callRemoteService</span><span class="o">(</span><span class="n">remoteClass</span><span class="o">.</span><span class="na">value</span><span class="o">(),</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">argTypes</span><span class="o">,</span> <span class="n">argValues</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">isSuccess</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="no">JSON</span><span class="o">.</span><span class="na">parseObject</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getResultValue</span><span class="o">(),</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getResultType</span><span class="o">()));</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"远程调用异常："</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>也就是最开始分析的核心类，这样便完成整个的rpc框架， 其中上面也就是最核心的代码，之前的就是单纯的涉及到spring 容器的操作。</p>

<p>那么总结一下：客户端主要的就是定义一个controller来接口测试的访问，然后使用spring的动态添加bean的特性，将需要的service实现类添加到容器中，其中实现类是通过动态代理的模型进行调用远端服务器具体实现类实现的。</p>

<p>ps：对应的网络连接类，正常的rpc框架应该是适应netty来进行连接，而不是使用http协议进行，本项目只是单纯的进行测试实现，所以借助spring 和springMVC框架来简单的模型以此rpc的实现过程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HttpUtil</span> <span class="o">{</span>

    <span class="cm">/**
     *  调用远程服务
     * @param identifier 包名
     * @param methodName 方法名
     * @param argTypes 参数类型
     * @param argValues 参数值
     * @return
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="nc">Result</span> <span class="nf">callRemoteService</span><span class="o">(</span><span class="nc">String</span> <span class="n">identifier</span><span class="o">,</span> <span class="nc">String</span> <span class="n">methodName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">argTypes</span><span class="o">,</span> <span class="nc">String</span> <span class="n">argValues</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NameValuePair</span><span class="o">&gt;</span> <span class="n">paramsList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="n">paramsList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BasicNameValuePair</span><span class="o">(</span><span class="s">"identifier"</span><span class="o">,</span> <span class="n">identifier</span><span class="o">));</span>
            <span class="n">paramsList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BasicNameValuePair</span><span class="o">(</span><span class="s">"methodName"</span><span class="o">,</span> <span class="n">methodName</span><span class="o">));</span>
            <span class="n">paramsList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BasicNameValuePair</span><span class="o">(</span><span class="s">"argTypes"</span><span class="o">,</span> <span class="n">argTypes</span><span class="o">));</span>
            <span class="n">paramsList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BasicNameValuePair</span><span class="o">(</span><span class="s">"argValues"</span><span class="o">,</span> <span class="n">argValues</span><span class="o">));</span>
            <span class="c1">//直接访问的就是根目录下的资源。</span>
            <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sendPost</span><span class="o">(</span><span class="s">"http://127.0.0.1:12311/"</span><span class="o">,</span> <span class="n">paramsList</span><span class="o">);</span>
            <span class="k">return</span> <span class="no">JSON</span><span class="o">.</span><span class="na">parseObject</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="nc">Result</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">Result</span><span class="o">.</span><span class="na">getFailResult</span><span class="o">(</span><span class="s">"触发远程调用失败"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 发送请求，根据url将请求发送出去。
     * @param url
     * @param nameValuePairList
     * @return
     * @throws Exception
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="nc">String</span> <span class="nf">sendPost</span><span class="o">(</span><span class="nc">String</span> <span class="n">url</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">NameValuePair</span><span class="o">&gt;</span> <span class="n">nameValuePairList</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">CloseableHttpResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">CloseableHttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClients</span><span class="o">.</span><span class="na">createDefault</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">HttpPost</span> <span class="n">post</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HttpPost</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
            <span class="nc">StringEntity</span> <span class="n">entity</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UrlEncodedFormEntity</span><span class="o">(</span><span class="n">nameValuePairList</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
            <span class="n">post</span><span class="o">.</span><span class="na">setEntity</span><span class="o">(</span><span class="n">entity</span><span class="o">);</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">post</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">statusCode</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getStatusLine</span><span class="o">().</span><span class="na">getStatusCode</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="mi">200</span> <span class="o">==</span> <span class="n">statusCode</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">EntityUtils</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">getEntity</span><span class="o">(),</span> <span class="s">"UTF-8"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">response</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">response</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>从中可以看出，其实也相当于发送了一个http请求。完。</p>

<h2 id="http与rpc之间的关系">HTTP与RPC之间的关系</h2>

<p><img src="https://pic.tyzhang.top/images/2020/10/09/RPC_HTTP.jpg" alt="RPC_HTTP.jpg" /></p>

<p>从图上可以看出，二者其实都可以看出在进行实现RPC的时候，底层的通信协议是可以使用HTTP协议的，另外单独的使用HTTP协议也是可以直接的实现调用的功能，理论上，HTTP的请求也是一种方法的调用，通过get或者post方法和url去调用方法，但是HTTP为了更高的可读性将请求头变得非常的臃肿，传输效率比较低，而RPC则是牺牲了可读性使得效率更高。</p>

<p>换句话说其实二者是一种功能，只不过应用的场景不同，而且针对点不同，HTTP是针对Client和Server 而 RPC是针对 Server 与Server之间的调用，另外RPC之间的调用效率更加的高，而且增加了ZK进行服务的自动配置与管理。</p>

<p>换句话说，上层的协议还是都是依赖于TCP/IP协议，总的来说就是基于字节流来进行编码，但是这些字节流是如何编码的？ 这就要看上层使用的是什么协议，要么是HTTP协议，要么是RPC或者是DNS等等应用层协议。只是一种解析的规范。</p>

<ul>
  <li>参考： <a href="https://www.zhihu.com/question/41609070">有了HTTP为什么还要RPC？</a></li>
</ul>


  </div>

    
<footer>
    <div style="color: #B0BEC5">标签：
    
    <a class="tag" style="color: #E91E63;font-weight:bold" href="/pages/tags#java">#java</a>
    
  </div>
</footer>






  
  
  

  
  
</article>


      <footer class="site-footer">
        <!-- <span class="site-footer-owner"> 刁文杰的博客©2018-2019.</span> -->
        
      <center>
          <span class="site-footer-credits">刁文杰的博客©2018-2020.</span><br>
          <!-- <span class="site-footer-credits" style="font-size:12px">Already <span id="sitetime"></span> days.</span><br> -->
          <!-- <span class="site-footer-credits" href>浙ICP备2020039014号</span><br> -->
          <a href="http://beian.miit.gov.cn/" class="site-footer-credits"> 浙ICP备2020039014号</a> <br>
      </center>

     
        

      </footer>
    </section>

    

    
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


      <script>
          ajax()
  function ajax(option){
    var xhr = null;
    if(window.XMLHttpRequest){
      xhr = new window.XMLHttpRequest();
    }else{ // ie
      xhr = new ActiveObject("Microsoft")
    }
    xhr.open("get","");
    xhr.send(null);
    xhr.onreadystatechange = function(){
      var time = null,
          curDate = null;
      if(xhr.readyState===2){
        // Get time
        time = xhr.getResponseHeader("Date");
        console.log(xhr.getAllResponseHeaders())
        curDate = new Date(time);
        document.getElementById("sitetime").innerHTML = (parseInt((((curDate.getTime() / 1000) - 1571133419 ) / 86400 )));
        
      }
    }
  }
      </script>
      
      <script src = '/assets/js/instantclick.min.js' data-no-instant></script>
      <script data-no-instant>InstantClick.init();</script>
      
  </body>
</html>
