<!DOCTYPE html>
<html lang="en">

  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#546E7A">

    

    <title>计算机网络学习</title>

    
      
    

    <link rel="canonical" href="www.diaowenjie.cn/2020/08/21/network.html">

    
    <meta name="keywords" itemprop="keywords" content="blog,css,html,php">
    <link rel="shortcut icon" sizes="128x128" href="/avatar/favicon.png">

    <meta name="robots" content="noarchive">

   
    <style>
.site-header {
   background-color: #546E7A;
   }
.page-header {
   background: url("https://api.dujin.org/bing/1920.php") no-repeat center; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size:cover; max-width:100%; margin: auto;text-align: center;margin-bottom:20px;
}
</style>

    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/fade.css">
    <meta name="google-site-verification" content="tb5-LFfZ4ccQdqYC0-JKdEi3uWBF3IFo8PNsDcahigs" />
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">刁文杰的博客</a>
    

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#ffffff" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#ffffff" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#ffffff" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
              
                <a class="page-link" href="/Billboard.html">Billboard</a>
              
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
              
                <a class="page-link" href="/archives.html">Archives</a>
              
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/links.html">Links</a>
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/pages/tags.html">Tags</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    
    
    <script>
      var OriginTitile = document.title;
      var titleTime;
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          document.title = '刁文杰的博客 ' + OriginTitile;
          clearTimeout(titleTime);
        }
        else {
          document.title = '刁文杰的博客 ' + OriginTitile;
          titleTime = setTimeout(function() {
            document.title = OriginTitile;
          }, 2000);
        }});

    </script>

    <section class="page-header">
      <h1 class="project-name">计算机网络学习</h1>
      <h2 class="project-tagline"></h2>
      
        <h2 class="project-date">
        <time datetime="2020-08-21T00:00:00+08:00" itemprop="datePublished">
          
          Aug 21, 2020
        </time>
        
        
          • <span itemprop="author" itemscope itemtype=""><span itemprop="name">刁文杰的博客</span></span>
        
        </h2>
      
    </section>

    <section class="main-content fade">

      <article itemscope itemtype="">

  <header class="post-header">
      <link rel="dns-prefetch" href="//cdn.bootcss.com" />
    <h1 class="post-title" itemprop="name headline">计算机网络学习</h1>
    <p class="post-meta">
      <time datetime="2020-08-21T00:00:00+08:00" itemprop="datePublished">
        
        Aug 21, 2020
      </time>
      </p>
  </header>
<script type="text/javascript" async
src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  document.getElementsByTagName("img").className="bbb";  
  </script>
  
  <div itemprop="articleBody">
    <blockquote>
  <p>计算机网络知识总结并整理。</p>
</blockquote>

<h1 id="目录">目录</h1>
<ul id="markdown-toc">
  <li><a href="#目录" id="markdown-toc-目录">目录</a></li>
  <li><a href="#物理层" id="markdown-toc-物理层">物理层</a></li>
  <li><a href="#数据链路层" id="markdown-toc-数据链路层">数据链路层</a>    <ul>
      <li><a href="#以太网中的mac层" id="markdown-toc-以太网中的mac层">以太网中的MAC层</a></li>
    </ul>
  </li>
  <li><a href="#网络层" id="markdown-toc-网络层">网络层</a></li>
  <li><a href="#运输层" id="markdown-toc-运输层">运输层</a>    <ul>
      <li><a href="#tcp" id="markdown-toc-tcp">TCP</a>        <ul>
          <li><a href="#tcp四次挥手为什么要等待2msl" id="markdown-toc-tcp四次挥手为什么要等待2msl"><strong>TCP四次挥手为什么要等待2MSL？</strong></a></li>
          <li><a href="#tcp为什么需要三次握手" id="markdown-toc-tcp为什么需要三次握手"><strong>TCP为什么需要三次握手？</strong></a></li>
        </ul>
      </li>
      <li><a href="#udp" id="markdown-toc-udp">UDP</a></li>
    </ul>
  </li>
  <li><a href="#应用层" id="markdown-toc-应用层">应用层</a></li>
  <li><a href="#tcp具体实现" id="markdown-toc-tcp具体实现">TCP具体实现</a>    <ul>
      <li><a href="#tcp-半连接队列和全连接队列满了会发生什么又该如何应对" id="markdown-toc-tcp-半连接队列和全连接队列满了会发生什么又该如何应对">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？</a></li>
    </ul>
  </li>
</ul>
<p>TCP/IP共有四层，但是一般学习都是使用五层，分层的机制，让整个数据变得很清晰并且很容易实现。指定标准的意思就是，只要遵守标准那么就能够一些协作。</p>

<h1 id="物理层">物理层</h1>

<p>这下面都是啥0-1信号，使用光纤传递信息，波分复用还有时分复用的模型，注意物理层都是电信号，也就是使用电磁波进行的数据传输，所以需要进行编码或者是解码等等。</p>

<h1 id="数据链路层">数据链路层</h1>

<p>OSI进行定义的功能。</p>

<p>三个功能：封装成帧，透明传输，差错检错。</p>

<p>对于封装成帧来说，因为都是传输连续的，所以如何在一段连续的信号中切分出来对应的帧？ 所以需要开始和结束标志，也就是 帧首部(SOH)+帧的数据部分+帧尾部(EOT)，对于透明传输来说，就是如果传输的字符中有SOH或则是EOT的话都需要进行转义，其中转义是自动进行的，所以上层是不需要考虑的，即做到透明。差错检测是使用CRC进行校验此次比特流有没有出错，即发送的与接收的是否一致，但是这种只能保证比特流上是一致的，并不是说明提供了可靠传输。因为传输可能出现的问题有：</p>

<ul>
  <li>帧重复</li>
  <li>帧丢失</li>
  <li>帧失序</li>
</ul>

<p>以上都是表明出现传输差错，这种错误一般都是传输层进行控制，底层不需要考虑这些问题，底层越简单越好。</p>

<h2 id="以太网中的mac层">以太网中的MAC层</h2>

<p>TCP/IP协议中的数据链路层叫做MAC层。mac地址是一个具有48位(6个字节)的地址，mac帧的组成如下：(需要说明的是一个字节有8位，以下是使用字节进行表示)</p>

<p><strong>目的地址(6) + 源地址(6) + 类型(2) + 数据(45~1500) + FCS(4)</strong> = 以太网MAC帧  <strong>MAC层</strong></p>

<p><strong>8字节 + 以太网MAC帧   =    物理层</strong></p>

<p>其中前面的8字节作为时间同步码，因为进行数据传输的两台电脑的时钟周期可能不一样，所以需要进行同步，否则会出现解析信号不一致的情况。帧同步码形如不断变换的101010，共有7字节，剩下的一个字节是帧开始标志符，10101011。系统检测到11以后就表面后面的是有效的mac帧。数据接收完以后，还会使用FCS进行检测是否有差错。另外因为以太网帧不会连续发送，所以数据接收完以后便到达了帧尾，因此也不需要结尾控制符。</p>

<p>无效MAC帧：</p>

<ul>
  <li>帧的长度不是整数个字节</li>
  <li>用收到的帧检验序列FCS查出有错误。</li>
  <li>收到的帧的MAC客户端数据字段的长度不在46-1500字节之间，考虑到MAC帧首部和尾部的长度共有18字节，可以得出有效的MAC帧长度为64-1518字节之间。</li>
</ul>

<p>如果收到无效帧，那么就直接的丢掉。</p>

<p>对于MAC层的操作有STP生成树，即交换机会自动的根据所连接的设备和自己的接口生成对应的MAC地址表，如果找不到就会使用进行广播，目标地址主机收到以后需要回复，其他主机收到检测到不是找自己的会直接的丢掉帧。为了避免生成的表中有环，使用STP生成树算法进行相应的优化，另外还能划分VLAN进行虚拟的局域网划分。二层交换机，如果有路由功能就是三层交换机。</p>

<h1 id="网络层">网络层</h1>

<p>网络层主要就是传输IP地址，首先在局域网中在不知道对方MAC地址，而知道IP地址的时候，就会使用ARP协议来询问对应的MAC地址是多少，目标主机收到ARP询问请求需要返回自己的MAC地址，其实在物理层中，数据的传输都是根据MAC地址进行传输，但是如何传输到目标地址，是使用IP进行指导的，通过划分子网还有路由进行控制。</p>

<ul>
  <li>地址解析协议 ARP address Resolution Protocol</li>
  <li>网际控制报文协议 ICMP Internet Control Message Proocol</li>
  <li>网际组管理协议 IGMP internet Group Management Protocol</li>
</ul>

<p>ICMP其实也就主要是一个ping和tracert命令比较有用。</p>

<p>报文头部：(首部)</p>

<p>版本(0-4) + 首部长度(4-8) + 区分服务(8-16) + 总长度(16-31)</p>

<p>标识(0-16) + 标志(16-19) + 片偏移(19-31)</p>

<p>生存时间(0-8) + 协议(8-16) + 首部检验和(16-31)</p>

<p>源地址(0-31)</p>

<p>目标地址(0-31)</p>

<p>可变部分</p>

<p>数据部分</p>

<p>(首部) + (数据部分)</p>

<p><strong>其中首部最短的是20个字节，最长为60字节。</strong></p>

<p>IP协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过576字节的数据报。这是 512字节的数据 + 最长60字节的报文头部，在加上4字节的富余量，得到576字节，如果在大于这个长度，就会进行数据分片。有限制主要是因为MAC帧有最大的长度，而IP数据是放在MAC帧中的，所以需要有个限制。对于分片来说，有两个标识符MF，DF ，more fragment，和 don’t fragement ，MF = 1分别表示更多的分片和DF = 1不能分片。</p>

<p>另外，IP数据包头部还会进行首部校验。但是不会对数据段进行效验。</p>

<p>然后就是子网的划分，或者是进行路由的选择，在进行路由选择的时候，主要使用的就是最长匹配原则，即如果匹配到多个子网，那么就找到最长的那个作为最终的路由。</p>

<p>关于路由协议：虽然可以自己手动指定路由，但是动态路由还是效率更高。</p>

<ul>
  <li>RIP 基于距离向量的路由选择协议，就是将自己的所有的接口发给邻居，然后邻居在在将自己的和收到的发给邻居，直到所有的都知道，能够很快的达到收敛，</li>
  <li>OSPF 开放最短路径优先 也就是跑了一个Dijkstra提出的最短路径算法，即在收到所有节点的路径以后，会计算自己到所有节点的最短路径，</li>
  <li>BGP 外部网关协议 路径向量路由选择协议。</li>
</ul>

<p>为了解决IP路由不行的问题，还搞出来了NAT，其实也就是相当于基于端口的映射，即内网的ip地址进行屏蔽，使用一个ip实现多个设备共同上网。</p>

<p>还有就是vpn，在不安全的ip层实现一个安全的网络传输。</p>

<h1 id="运输层">运输层</h1>

<p>滑动窗口、流量控制、拥塞控制机制。</p>

<p>两个主机的通信其实是两个进程之间的通信，底层是有TCP提供的端到端的服务。因为IP层可以将一段数据发送到对应的主机，但是主机收到报文后该将报文交给谁处理呢？ 就是传输层解决的问题，即将数据交给对应的线程，通过端口进行区别线程，类似于线程ID，线程会对收到的数据进行处理。</p>

<blockquote>
  <p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。另外，运输层还会对报文进行差错检测，也就是解释了为什么IP层只对报文头进行差错检测，而不检测报文的，因为运输层已经进行了差错检测。</p>
</blockquote>

<p>对于面向连接的TCP，尽管下层的网络不可靠，但是TCP提供的逻辑信道相当于一种全双工的可靠信道，但是无连接的UDP是一种不可靠的信道。</p>

<h2 id="tcp">TCP</h2>

<p><strong>传输控制协议TCP (Transmission Control Protocol)</strong>:</p>

<p>主要的东西包括三次握手，四次挥手，还有就是拥塞控制，滑动窗口协议，主要解决的问题是如何在一个不可靠的连接上进行可靠的传输。</p>

<p>TCP报文段的首部格式：</p>

<p>源端口(16)+目的端口(16)</p>

<p>序号(32)</p>

<p>确认号(32)</p>

<p>数据偏移(4) + 保留 + URG + ACK + PSH + RST + SYN + FIN + 窗口()</p>

<p>检验和+ 紧急指针</p>

<p>选项 + 填充</p>

<p>值的说明的是，数据偏移也就是表明头部是是有多长，然后就是各种标志位，还有就是滑动窗口的长度，滑动窗口值的单位是字节，也就是最大是多少字节。另外序号的话则是发送了多少字节，如果是累积确认的话，比如seq为100，确认号则为101表明前100已经接收到。另外TCP接受的数据需要严格按照序号进行排列，然后按照序号将数据进行恢复，从而保证数据有序。</p>

<p>对于三次握手协议来说，也就是 A 先向B发送一个SYN的请求，然后B回复 SYN ACK的请求， 然后A在发送ACK 之后便开始进行数据的传输。</p>

<p>对于四次挥手来说，A主动发送一个FIN表示要结束连接，然后B发送一个ACK表示已经接受到了断开连接的请求，当B把自己所有需要发送的数据发送完以后，便也向A发送一个FIN的数据，此时A收到以后再次发送一个ACK表明确认断开连接，发送以后A还要进行定时，防止ACK没有被B收到，当B收到ACK以后便断开连接，当A在2个MSS时间没有收到任何消息以后，也关闭连接。 如果有异常，比如A的ACK丢失，那么B还会发送一个FIN请求，然后A会重传ACK。</p>

<p>还有就是拥塞控制算法。</p>

<p>主要有慢开始，超时重传，快开始等等。拥塞避免，快重传，快恢复。</p>

<p>cwnd = congestion window 拥塞控制窗口  rwnd   receive window 接受窗口 ssthresh  慢开始阈值。</p>

<p>为什么会有慢开始？ 主要是因为慢慢的增加传输的数据比一开始就往链路中添加大量的数据好很多。</p>

<p>首先对于慢开始来说，在没有到达ssthresh 之前，首先是cwnd指数形式增加，初始为1，然后是为2，然后是4，直到到达ssthresh ，然后cwnd++，即每次都是+1，如果出现超时情况，那么就直接将ssthresh  =  cwnd /2 ，然后将cwnd = 1，重新执行慢开始算法。</p>

<p>对于快重传来说，是一种优化的版本，因为超时很容易发生，可能并不是拥塞导致，即当接受方发现一个数据丢失时，直接发送三个ACK表示数据丢失，这时候发送方并不将cwnd直接变成1，而是将cwnd = ssthresh = cwnd/2  ，然后重新cwnd++.</p>

<p>另外，处了等待计时器外， TCP还设置一个包活计时器，它是处理正常连接在中一台主机直接挂掉，避免一直重连浪费资源。其实也说明了一个很重要的思想，避免傻傻等待或则是死锁的一个很好的方法就是维护一个计时器，人生不也是如此么？</p>

<h3 id="tcp四次挥手为什么要等待2msl"><strong>TCP四次挥手为什么要等待2MSL？</strong></h3>

<p><strong>MSL (Maximum Segment Lifetime)</strong> ： 报文最大生存时间，一个TCP报文段能在连接上存在（没有丢失）的最长时间，是一个相对TimeoutInterval来说很大的值。此举的目的是让双方的报文都消失才能下线，不会再出现异常的情况。放在自己的ACK没有被对方接收到，保证双方都正常关闭TCP连接。</p>

<h3 id="tcp为什么需要三次握手"><strong>TCP为什么需要三次握手？</strong></h3>

<p><a href="https://www.zhihu.com/question/24853633">参考知乎</a></p>

<p>主要是TCP规定需要所有有的连接都需要确认回复才能确定对象已经收到了发送的数据包，还有一个重要的作用就是交换双发的起始序列号。因为起始对于一次新的连接，TCP都会随机生成一个32位长的序列号作为自己的初始序列号，之后发送的数据都是从这个初始序列号开始编号，而接受方也是如此，也会有一个自己的起始随机编号，那么回到TCP三次握手这个问题？ 他们握手的目的是什么呢？就是为了交换自己的初始序列编号，表明编号以后的数据都是合法的数据，所以需要三次握手，即双方都确认已经收到对方的起始编号，如果只有两次握手的话，B方不知道A有没有知道自己的起始编号所以需要三次握手，其实三次握手是四次握手的简化版。</p>

<h2 id="udp">UDP</h2>

<p><strong>用户数据报协议 UDP (User Datagram Protocol)</strong>：</p>

<p>主要是用于视频直播等。</p>

<h1 id="应用层">应用层</h1>

<p>HTTP状态码：</p>

<p>1XX:表示通知信息，如请求受到了或正在进行处理</p>

<p>2XX:表示成功，如接受了或知道了</p>

<p>3XX: 表示重定向</p>

<p>4XX:表示客户端差错</p>

<p>5XX:表示服务器差错。</p>

<p>对于HTTP来说，是面向无连接的，即用户第一次访问和第二次访问都是一次新的访问，另外对于HTTP请求头与请求体来说，主要就是包括方法，url，浏览器版本号，即请求头和请求体。</p>

<p>对于响应来说主要包括响应头和相应体，头部包括状态码，HTTP版本，解释状态码的版本，然后就是响应体了，其实可以仔细想想到底接受的与发送的东西到底都是什么？ 然后就是AJAX发送的数据。</p>

<h1 id="tcp具体实现">TCP具体实现</h1>

<h2 id="tcp-半连接队列和全连接队列满了会发生什么又该如何应对">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？</h2>

<p><a href="https://zhuanlan.zhihu.com/p/144785626">参考链接</a></p>

<p>上面分析的都是理论东西，下面说的就是TCP具体在Linux上的实现。</p>

<p>半连接队列  SYN队列，即初始换SYN的时候，所有的连接都是放在SYN队列中。</p>

<p>全连接队列 也成accept队列，到了全连接队列的时候，就是到了已经完成了TCP三次握手，然后开始发送数据的节点，Linux使用一个全连接队列进行维护所有的连接。</p>

<p>针对于半连接队列的就又syn洪泛攻击。解决的方法有如下：</p>

<ul>
  <li>增大半连接队列；</li>
  <li>开启 tcp_syncookies 功能</li>
  <li>减少 SYN+ACK 重传次数</li>
</ul>

<p>其中syn洪泛攻击就是一直发送SYN请求，然后就断开连接，此时服务器如果发现异常就会隔断时间重发SYN -ACK，如果太多就会占满半连接队列。</p>


  </div>

    
<footer>
    <div style="color: #B0BEC5">标签：
    
    <a class="tag" style="color: #E91E63;font-weight:bold" href="/pages/tags#java">#java</a>
    
  </div>
</footer>






  
  
  

  
  
</article>


      <footer class="site-footer">
        <!-- <span class="site-footer-owner"> 刁文杰的博客©2018-2019.</span> -->
        
      <center>
          <span class="site-footer-credits">刁文杰的博客©2018-2020.</span><br>
          <!-- <span class="site-footer-credits" style="font-size:12px">Already <span id="sitetime"></span> days.</span><br> -->
          <!-- <span class="site-footer-credits" href>浙ICP备2020039014号</span><br> -->
          <a href="http://beian.miit.gov.cn/" class="site-footer-credits"> 浙ICP备2020039014号</a> <br>
      </center>

     
        

      </footer>
    </section>

    

    
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


      <script>
          ajax()
  function ajax(option){
    var xhr = null;
    if(window.XMLHttpRequest){
      xhr = new window.XMLHttpRequest();
    }else{ // ie
      xhr = new ActiveObject("Microsoft")
    }
    xhr.open("get","");
    xhr.send(null);
    xhr.onreadystatechange = function(){
      var time = null,
          curDate = null;
      if(xhr.readyState===2){
        // Get time
        time = xhr.getResponseHeader("Date");
        console.log(xhr.getAllResponseHeaders())
        curDate = new Date(time);
        document.getElementById("sitetime").innerHTML = (parseInt((((curDate.getTime() / 1000) - 1571133419 ) / 86400 )));
        
      }
    }
  }
      </script>
      
      <script src = '/assets/js/instantclick.min.js' data-no-instant></script>
      <script data-no-instant>InstantClick.init();</script>
      
  </body>
</html>
