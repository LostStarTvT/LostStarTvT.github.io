<!DOCTYPE html>
<html lang="en">

  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#546E7A">

    

    <title>Algorithm：DP算法</title>

    
      
    

    <link rel="canonical" href="www.diaowenjie.cn/2020/08/05/dp.html">

    
    <meta name="keywords" itemprop="keywords" content="blog,css,html,php">
    <link rel="shortcut icon" sizes="128x128" href="/avatar/favicon.png">

    <meta name="robots" content="noarchive">

   
    <style>
.site-header {
   background-color: #546E7A;
   }
.page-header {
   background: url("https://api.dujin.org/bing/1920.php") no-repeat center; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size:cover; max-width:100%; margin: auto;text-align: center;margin-bottom:20px;
}
</style>

    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/fade.css">
    <meta name="google-site-verification" content="tb5-LFfZ4ccQdqYC0-JKdEi3uWBF3IFo8PNsDcahigs" />
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">刁文杰的博客</a>
    

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#ffffff" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#ffffff" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#ffffff" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
              
                <a class="page-link" href="/Billboard.html">Billboard</a>
              
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
              
                <a class="page-link" href="/archives.html">Archives</a>
              
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/links.html">Links</a>
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/pages/tags.html">Tags</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    
    
    <script>
      var OriginTitile = document.title;
      var titleTime;
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          document.title = '刁文杰的博客 ' + OriginTitile;
          clearTimeout(titleTime);
        }
        else {
          document.title = '刁文杰的博客 ' + OriginTitile;
          titleTime = setTimeout(function() {
            document.title = OriginTitile;
          }, 2000);
        }});

    </script>

    <section class="page-header">
      <h1 class="project-name">Algorithm：DP算法</h1>
      <h2 class="project-tagline"></h2>
      
        <h2 class="project-date">
        <time datetime="2020-08-05T00:00:00+08:00" itemprop="datePublished">
          
          Aug 5, 2020
        </time>
        
        
          • <span itemprop="author" itemscope itemtype=""><span itemprop="name">刁文杰的博客</span></span>
        
        </h2>
      
    </section>

    <section class="main-content fade">

      <article itemscope itemtype="">

  <header class="post-header">
      <link rel="dns-prefetch" href="//cdn.bootcss.com" />
    <h1 class="post-title" itemprop="name headline">Algorithm：DP算法</h1>
    <p class="post-meta">
      <time datetime="2020-08-05T00:00:00+08:00" itemprop="datePublished">
        
        Aug 5, 2020
      </time>
      </p>
  </header>
<script type="text/javascript" async
src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  document.getElementsByTagName("img").className="bbb";  
  </script>
  
  <div itemprop="articleBody">
    <blockquote>
  <p>打家劫舍题目DP分析。</p>
</blockquote>

<h2 id="目录">目录</h2>
<ul id="markdown-toc">
  <li><a href="#目录" id="markdown-toc-目录">目录</a></li>
  <li><a href="#打家劫舍1" id="markdown-toc-打家劫舍1">打家劫舍1</a></li>
  <li><a href="#打家劫舍2" id="markdown-toc-打家劫舍2">打家劫舍2</a></li>
  <li><a href="#打家劫舍3" id="markdown-toc-打家劫舍3">打家劫舍3</a></li>
  <li><a href="#买卖股票问题1-买一次" id="markdown-toc-买卖股票问题1-买一次">买卖股票问题1 买一次</a></li>
  <li><a href="#买卖股票问题2-不限制" id="markdown-toc-买卖股票问题2-不限制">买卖股票问题2 不限制</a></li>
  <li><a href="#买卖股票问题3-手续费" id="markdown-toc-买卖股票问题3-手续费">买卖股票问题3 手续费</a></li>
  <li><a href="#买卖股票问题4-买两次" id="markdown-toc-买卖股票问题4-买两次">买卖股票问题4 买两次</a></li>
  <li><a href="#最大子序和" id="markdown-toc-最大子序和">最大子序和</a></li>
</ul>
<h1 id="打家劫舍1">打家劫舍1</h1>

<p><a href="https://leetcode-cn.com/problems/house-robber"><strong>题目描述</strong></a>：专业小偷投东西，但是连续的房间不能偷，只能隔着房间偷，如何保证偷的最大的钱？</p>

<blockquote>
  <p>输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>

<p><strong>解题思路：</strong> 使用动态规划进行找出最大的值。</p>

<p>本题具有最优子结构，对于dp[n]来说，对于该节点的值有加或者不加的选择，又因为相邻的不能选择，所以有如下最优子结构</p>

<p>dp[n] = Max( dp[n-1], dp[n-2] + num[n]) //  找出选择与不选择之间的最大值。</p>

<p>另外，如何保证在选择n的时候，n-1没有被选？</p>

<p>主要分为两种情况，</p>

<ol>
  <li>n-1没有被选时， 此时dp[n-1] = dp[n-2]，故此时 dp[n-1]  + num[n] 与  dp[n-2] + num[n] 一样的。</li>
  <li>n-1被选择时， 这时候便不能用dp[n-1] + num[n]，</li>
</ol>

<p>所以需要使用 dp[n-2] + num[n] 保证在选择n节点的时候不会选中n-1节点。 有点绕但是需要理解一下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//动态规划问题：</span>

        <span class="c1">// 转移方程 dp[i] = num[i] + dp[i-2] 因为临近的不能偷 当偷第i个房间的时候</span>
        <span class="c1">// dp[i] = dp[n-1] 当不偷第i个房间，</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> 
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">//存储状态方程</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span> <span class="c1">// 找到最大的值。 dp问题。</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">//状态转移方程。</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// 因为是n为长度，即返回最后一个值而已。。</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="打家劫舍2">打家劫舍2</h1>

<p><a href="https://leetcode-cn.com/problems/house-robber-ii/"><strong>题目描述</strong></a>：在上一题的基础上，此时表示的是在一个循环房屋，因为需要保证相邻的不能偷，所以首尾的房间不能同时的偷。</p>

<p><strong>解题思路：</strong> 刚开始以为是使用循环数组进行处理问题，对于处理循环列表有个很好的方法即 直接将”复制“一份直接添加到尾部，然后处理一个长的数组，此时for循环的长度为 i&lt;num.length * 2 -1，对于索引数组的下标使用取模的方法 index = i%num.length， 这样就不需要考虑异常的处理，但是此题不是如此处理，既然首尾不能同时抢劫，那么就分为了两个子问题， 有首无尾，有尾无首的处理方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="cm">/** 
        dp[0] = nums[0]
        dp[1] = Math.max(num[0],num[1]);
        dp[i] = Math.max(dp[i-1],dp[i-2] + nums[i]) // 偷或者不偷。
        */</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="c1">// 分为两种， nums[0: n-2]  nums[1:n-1] 即将其表示为两个数组  然后求出来更大的值。。。卧槽哦</span>
        
        <span class="c1">// 带nums[0] 玩。 n表示数组的长度， 0 - n-1 表示有效数据。</span>
        <span class="kt">int</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">robHelper</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="c1">// 不带nums[0] 玩。 即数据为 1-n </span>
        <span class="kt">int</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">robHelper</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="n">n</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">res1</span> <span class="o">&gt;</span> <span class="n">res2</span> <span class="o">?</span> <span class="nl">res1:</span> <span class="n">res2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">robHelper</span><span class="o">(</span><span class="kt">int</span> <span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="kt">int</span> <span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">//虽然会多一个 但是也没事。</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">],</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]);</span>

        <span class="c1">// 要从 + 2开始进行执行。</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// 只和 dp[i-1] 和dp[i-2]有关，所以可以使用两个变量进行实现。</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>实际上就是将本题分解为打家劫舍1的两个端而已，处理的方式一致。</p>

<h1 id="打家劫舍3">打家劫舍3</h1>

<p><a href="https://leetcode-cn.com/problems/house-robber-iii/"><strong>题目描述</strong></a>： 这次是房子形成了一个树，然后必须隔层才能偷。 聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>

<blockquote>
  <p>输入: [3,2,3,null,3,null,1]</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> **3**
/ \\    2   3
\   \\ 
 **3**   **1**
</code></pre></div>  </div>

  <p>输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</p>
</blockquote>

<p><strong>解题思路</strong>：因为是树形，刚开始以为是使用先序遍历转成数组然后在使用上面的动态规划，其实不用，按照题目大意可以发现，小偷每次要么抢劫父与孙子节点，要么就抢劫儿子节点，也就是说找到 父亲+四个孙子 与 儿子 之间的关系进行比较便可以。以上就是最有子结构的问题， 也即是dp的问题。另外如果可以看出，在因为对于每一层都会进行计算其值，因为儿子节点也会成为父亲节点，即重复计算其层的值，所以使用Map进行优化算法，记录已经计算过的值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 什么叫做递归？ 也就是找到一层的事，然后其他的就会自动的完成，并且找到出口就行。</span>

        <span class="c1">// 树型动态规划。。  也就说 将其分散为 三个问题， 爷爷 抢劫 + 四个孙子抢劫  与 儿子抢劫得到的钱谁大就是谁</span>
        <span class="c1">// 为什么使用map 主要是因为在计算的时候时候已经找到最大的值，然后使用一个map 存储已经搞定的值。避免重复计算。。</span>
        <span class="c1">// 如果超时就需要使用map进行计算。，</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">return</span> <span class="nf">robHelper</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">map</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">robHelper</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">root</span><span class="o">))</span> <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        
        <span class="kt">int</span> <span class="n">money</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span> <span class="c1">// 爷爷的钱</span>

        <span class="c1">// 收集到 孙子抢到的钱，</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span> <span class="c1">// 这个通过判断左右叶子节点是否为空然后再去访问的情况比较好用。</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="o">(</span><span class="n">robHelper</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">map</span><span class="o">)</span> <span class="o">+</span> <span class="n">robHelper</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">map</span><span class="o">)</span> <span class="o">);</span> 
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">money</span> <span class="o">+=</span> <span class="o">(</span><span class="n">robHelper</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">map</span><span class="o">)</span> <span class="o">+</span> <span class="n">robHelper</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">map</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// 将孙子和父亲抢的钱 与儿子的进行比较。</span>
        <span class="kt">int</span> <span class="n">son</span> <span class="o">=</span> <span class="o">(</span><span class="n">robHelper</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">map</span><span class="o">)</span> <span class="o">+</span> <span class="n">robHelper</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">map</span><span class="o">));</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span>  <span class="n">money</span> <span class="o">&gt;</span> <span class="n">son</span> <span class="o">?</span> <span class="n">money</span> <span class="o">:</span> <span class="n">son</span><span class="o">;</span>
        
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span><span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="买卖股票问题1-买一次">买卖股票问题1 买一次</h1>

<p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">题目描述</a></strong> 给定一个数组，表示第i日的股票价格，在只能买卖一次股票的情况下找到最大的利润。</p>

<blockquote>
  <p>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
</blockquote>

<p><strong>解题思路：</strong> 也是属于dp问题，正常思维是低买高卖才会利润最大，所以需要维护一个价格最下值和利润最大值。 但是有个点值得注意，即在买入股票以后才能卖出股票，基于这个点，只需要先维护一个股票价格的最小值，然后先找最小值，然后在判断当前的价格在减去最小值的时候是否已经最大。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 相当于维护一个数组， 找出最大值与最小值。 但是是正序的。</span>
        <span class="kt">int</span> <span class="n">maxPro</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 最大的利润</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>

            <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">){</span> <span class="c1">// 因为是单语句执行， 并且是 互斥的。</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">min</span> <span class="o">&gt;</span> <span class="n">maxPro</span><span class="o">){</span>
                <span class="n">maxPro</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">min</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">maxPro</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>但是以上没有用到dp的经典子结构，参考别人的做法：</p>

<p><strong><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247485288&amp;idx=1&amp;sn=fd043fc723f38bcaecc90d9945981f8a&amp;chksm=fa0e68e9cd79e1ffd965205bb06b1731539bf2e0bbc5991664f5d1d9721b346ec08c85bb9042&amp;scene=21#wechat_redirect">经典DP做法</a></strong></p>

<p>对于买来说，买之后可以卖出（进入卖状态），也可以不再进行股票交易（保持买状态）。</p>

<p>对于卖来说，卖出股票后不在进行股票交易（还在卖状态）。</p>

<p>只有在手上的钱才算钱，手上的钱购买当天的股票后相当于亏损。也就是说当天买的话意味着损失<code class="language-plaintext highlighter-rouge">-prices[i]</code>，当天卖的话意味着增加<code class="language-plaintext highlighter-rouge">prices[i]</code>，当天卖出总的收益就是 <code class="language-plaintext highlighter-rouge">buy+prices[i]</code> 。</p>

<p>所以我们只要考虑当天买和之前买哪个收益更高，当天卖和之前卖哪个收益更高。</p>

<ul>
  <li>buy = max(buy, -price[i])  （注意：根据定义 buy 是负数）</li>
  <li>sell = max(sell,  prices[i] + buy)</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">buy</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">sell</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">buy</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span> <span class="n">buy</span> <span class="o">,</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">sell</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span> <span class="n">sell</span> <span class="o">,</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">buy</span><span class="o">);</span> <span class="c1">// 找出 现阶段与 买股票之后最大的值。 不用担心</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sell</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>其实主要的思想也是一致的，对于buy来说，也是找到prices中的最小值，即负值最大。 对于sell来说，表明自己赚的钱，因为要保持sell是赚到更多的钱，所以是比较卖与不卖的值。</p>

<h1 id="买卖股票问题2-不限制">买卖股票问题2 不限制</h1>

<p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">问题描述</a></strong>： 上个问题是只能买卖一次，这次是不限制买卖，但是一此只能持有一个股票，即在没有卖出的时候，不能再买股票。求最大的利润。</p>

<blockquote>
  <p>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
   随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>

<p><strong>解题思路：</strong> 这里利用了一个很机智的做法，因为不限制买卖，所以采用当有上升的趋势的时候，便进行相减统计。<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode/">参考</a></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 这题又是 尽可能的买进卖出。 但是在买进之前要卖出去。</span>
        <span class="c1">// 可以简单的认为，只要升值就进行买入，</span>

        <span class="kt">int</span> <span class="n">maxPro</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="c1">//只要升值就买入卖出。 然后记录总值</span>
                <span class="n">maxPro</span> <span class="o">+=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxPro</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用标准的dp解决: 所以说这个是更优的。</p>

<p><strong>转移方程</strong></p>

<p>对比上题，这里可以有无限次的买入和卖出，也就是说 <strong>买入</strong> 状态之前可拥有 <strong>卖出</strong> 状态，所以买入的转移方程需要变化。</p>

<ul>
  <li>buy = max(buy, sell - price[i]) 	买股票以后手里剩余的钱。</li>
  <li>sell = max(sell,  buy + prices[i] )  卖掉股票手里剩余的钱。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">buy</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">sell</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sell</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">sell</span><span class="o">,</span> <span class="n">buy</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// sell 表示卖掉以后手里剩余的钱， 所以拿买的花掉的钱减去卖掉的价格。 也就是一个差价。</span>
            <span class="n">buy</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span> <span class="n">buy</span><span class="o">,</span> <span class="n">sell</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// buy 表示买了以后手里剩余的钱， 即手里的钱-价格 表示如果买的话还剩多少钱，</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sell</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从上面可以看出，其实也就是一直在计算卖了以后减去买入花掉钱 手里还剩多少钱。 所以就需要一直 使用  卖出价 - 买入价。 其中buy 初始为 赋值 ，因为初始没钱。另外，以为第一次是买入 buy = 0， 所以先考虑卖出之后剩余的钱， 然后在考虑买入还剩的钱。</p>

<h1 id="买卖股票问题3-手续费">买卖股票问题3 手续费</h1>

<p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">题目描述</a></strong> 可以任意买卖股票，但是在买卖一次的时候会收fee手续费，求出最大的利润。</p>

<blockquote>
  <p>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:<br />
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fee</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 说好的贪心算法？</span>
        <span class="kt">int</span> <span class="n">sell</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 卖出的金额。</span>
        <span class="kt">int</span> <span class="n">buy</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 表示当前持有的金额</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sell</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">sell</span><span class="o">,</span> <span class="n">buy</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">fee</span><span class="o">);</span> <span class="c1">// 减去手续费。</span>
            <span class="n">buy</span>  <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">buy</span><span class="o">,</span> <span class="n">sell</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sell</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这道题也就是在上一道题的基础上，直接的减去fee就行。</p>

<h1 id="买卖股票问题4-买两次">买卖股票问题4 买两次</h1>

<p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">题目描述</a></strong>：在上一个问题的基础上，这次最多只能卖两次股票，然后求出来最大的利润</p>

<blockquote>
  <p>输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
</blockquote>

<p><strong>状态</strong></p>

<p>有 <strong>第一次买入（fstBuy）</strong> 、 <strong>第一次卖出（fstSell）</strong>、<strong>第二次买入（secBuy）</strong> 和 <strong>第二次卖出（secSell）</strong> 这四种状态。</p>

<p><strong>转移方程</strong></p>

<p>这里可以有两次的买入和卖出，也就是说 <strong>买入</strong> 状态之前可拥有 <strong>卖出</strong> 状态，所以买入和卖出的转移方程需要变化。</p>

<ul>
  <li>fstBuy = max(fstBuy ，  -price[i])</li>
  <li>fstSell = max(fstSell，fstBuy + prices[i] )</li>
  <li>secBuy = max(secBuy ，fstSell -price[i]) (受第一次卖出状态的影响)</li>
  <li>secSell = max(secSell ，secBuy + prices[i] )</li>
</ul>

<p><strong>边界</strong></p>

<ul>
  <li>一开始 <code class="language-plaintext highlighter-rouge">fstBuy = -prices[0]</code></li>
  <li>买入后直接卖出，<code class="language-plaintext highlighter-rouge">fstSell = 0</code></li>
  <li>买入后再卖出再买入，<code class="language-plaintext highlighter-rouge">secBuy - prices[0]</code></li>
  <li>买入后再卖出再买入再卖出，<code class="language-plaintext highlighter-rouge">secSell = 0</code></li>
</ul>

<p>最后返回 secSell 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">fstBuy</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">,</span> <span class="n">fstSell</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">secBuy</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">,</span> <span class="n">secSell</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">fstBuy</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">fstBuy</span><span class="o">,</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">fstSell</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">fstSell</span><span class="o">,</span> <span class="n">fstBuy</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">secBuy</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">secBuy</span><span class="o">,</span> <span class="n">fstSell</span> <span class="o">-</span>  <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">secSell</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">secSell</span><span class="o">,</span> <span class="n">secBuy</span> <span class="o">+</span>  <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> 
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">secSell</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面这道题还没有解决。</p>

<h1 id="最大子序和">最大子序和</h1>

<p><strong><a href="https://leetcode-cn.com/problems/maximum-subarray/">题目大意</a></strong>： 找出一个数组中的最大连续子序列。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: <span class="o">[</span><span class="nt">-2</span>,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 <span class="o">[</span>4,-1,2,1] 的和最大，为 6。
</code></pre></div></div>

<p><strong>解题思路</strong> ：这个思想也是动态规划，但是与上面的打家劫舍有点不同，就是这个状态转移方程，从上面的可以看出，之前的dp方程都是</p>

<p>dp[i] = Math.max(dp[i-1],dp[i-2] + num[i]) ;即判断当前节点加与不加的最大值，通过dp[i-1]与dp[i-2]与之控制，即当前值加与不加，但是这个最大子序和不一样，这是因为是连续的，而打家劫舍是找到最大值，所以需要判断之前的子序加上当前节点 和与以当前节点开始的子序和谁更大，如下：</p>

<p>dp[i] = Math.max(dp[i-1] + nums[i] , num[i]);只有一个单独的num[i]进行判断，所有需要具体问题具体分析，然后需要一个max进行记录最大子序列值。</p>

<p>max = Math.max(max,dp[i]);</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// if (nums.length == 0) return 0;</span>
        
        <span class="c1">// 使用两个变量进行测试。</span>
        <span class="c1">// int max_end = nums[0]; </span>
        <span class="c1">// int max_tmp = nums[0];</span>
        <span class="c1">// for (int i = 1; i &lt; nums.length; i++) {</span>
            
        <span class="c1">//     max_end = Math.max(max_end + nums[i],nums[i]); // 是新开一个节点还是 接着更好。</span>
        <span class="c1">//     max_tmp = Math.max(max_end,max_tmp);// 是否更大，</span>
        <span class="c1">// }</span>
        <span class="c1">// return max_tmp;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 因为是截断的，如果当前的值比连续的更大，那么就重新开始，而以前的dp是 一直连续的。</span>
            <span class="c1">// 比较的是如果加上当前节点，与以当前节点开始的新节点的值 找到更大值。只是记录的是对于i节点来说，而不是整体。</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


  </div>

    
<footer>
    <div style="color: #B0BEC5">标签：
    
    <a class="tag" style="color: #E91E63;font-weight:bold" href="/pages/tags#Algorithm">#Algorithm</a>
    
  </div>
</footer>






  
  
  

  
  
</article>


      <footer class="site-footer">
        <!-- <span class="site-footer-owner"> 刁文杰的博客©2018-2019.</span> -->
        
      <center>
          <span class="site-footer-credits">刁文杰的博客©2018-2020.</span><br>
          <!-- <span class="site-footer-credits" style="font-size:12px">Already <span id="sitetime"></span> days.</span><br> -->
          <!-- <span class="site-footer-credits" href>浙ICP备2020039014号</span><br> -->
          <a href="http://beian.miit.gov.cn/" class="site-footer-credits"> 浙ICP备2020039014号</a> <br>
      </center>

     
        

      </footer>
    </section>

    

    
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


      <script>
          ajax()
  function ajax(option){
    var xhr = null;
    if(window.XMLHttpRequest){
      xhr = new window.XMLHttpRequest();
    }else{ // ie
      xhr = new ActiveObject("Microsoft")
    }
    xhr.open("get","");
    xhr.send(null);
    xhr.onreadystatechange = function(){
      var time = null,
          curDate = null;
      if(xhr.readyState===2){
        // Get time
        time = xhr.getResponseHeader("Date");
        console.log(xhr.getAllResponseHeaders())
        curDate = new Date(time);
        document.getElementById("sitetime").innerHTML = (parseInt((((curDate.getTime() / 1000) - 1571133419 ) / 86400 )));
        
      }
    }
  }
      </script>
      
      <script src = '/assets/js/instantclick.min.js' data-no-instant></script>
      <script data-no-instant>InstantClick.init();</script>
      
  </body>
</html>
