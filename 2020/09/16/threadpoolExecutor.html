<!DOCTYPE html>
<html lang="en">

  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#546E7A">

    

    <title>Java：线程池源码解析</title>

    
      
    

    <link rel="canonical" href="www.diaowenjie.cn/2020/09/16/threadpoolExecutor.html">

    
    <meta name="keywords" itemprop="keywords" content="blog,css,html,php">
    <link rel="shortcut icon" sizes="128x128" href="/avatar/favicon.png">

    <meta name="robots" content="noarchive">

   
    <style>
.site-header {
   background-color: #546E7A;
   }
.page-header {
   background: url("https://api.dujin.org/bing/1920.php") no-repeat center; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size:cover; max-width:100%; margin: auto;text-align: center;margin-bottom:20px;
}
</style>

    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/fade.css">
    <meta name="google-site-verification" content="tb5-LFfZ4ccQdqYC0-JKdEi3uWBF3IFo8PNsDcahigs" />
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">刁文杰的博客</a>
    

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#ffffff" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#ffffff" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#ffffff" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
              
                <a class="page-link" href="/Billboard.html">Billboard</a>
              
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
              
                <a class="page-link" href="/archives.html">Archives</a>
              
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/links.html">Links</a>
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/pages/tags.html">Tags</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    
    
    <script>
      var OriginTitile = document.title;
      var titleTime;
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          document.title = '刁文杰的博客 ' + OriginTitile;
          clearTimeout(titleTime);
        }
        else {
          document.title = '刁文杰的博客 ' + OriginTitile;
          titleTime = setTimeout(function() {
            document.title = OriginTitile;
          }, 2000);
        }});

    </script>

    <section class="page-header">
      <h1 class="project-name">Java：线程池源码解析</h1>
      <h2 class="project-tagline"></h2>
      
        <h2 class="project-date">
        <time datetime="2020-09-16T00:00:00+08:00" itemprop="datePublished">
          
          Sep 16, 2020
        </time>
        
        
          • <span itemprop="author" itemscope itemtype=""><span itemprop="name">刁文杰的博客</span></span>
        
        </h2>
      
    </section>

    <section class="main-content fade">

      <article itemscope itemtype="">

  <header class="post-header">
      <link rel="dns-prefetch" href="//cdn.bootcss.com" />
    <h1 class="post-title" itemprop="name headline">Java：线程池源码解析</h1>
    <p class="post-meta">
      <time datetime="2020-09-16T00:00:00+08:00" itemprop="datePublished">
        
        Sep 16, 2020
      </time>
      </p>
  </header>
<script type="text/javascript" async
src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  document.getElementsByTagName("img").className="bbb";  
  </script>
  
  <div itemprop="articleBody">
    <blockquote>
  <p>学习线程池的操作逻辑。</p>
</blockquote>

<h1 id="目录">目录</h1>
<ul id="markdown-toc">
  <li><a href="#目录" id="markdown-toc-目录">目录</a></li>
  <li><a href="#线程池参数" id="markdown-toc-线程池参数">线程池参数</a></li>
  <li><a href="#继承关系" id="markdown-toc-继承关系">继承关系</a></li>
  <li><a href="#exexutors" id="markdown-toc-exexutors">Exexutors</a></li>
  <li><a href="#executorservice" id="markdown-toc-executorservice">ExecutorService</a></li>
  <li><a href="#threadpoolexecutor" id="markdown-toc-threadpoolexecutor">ThreadPoolExecutor</a>    <ul>
      <li><a href="#一属性知识" id="markdown-toc-一属性知识">一、属性知识</a>        <ul>
          <li><a href="#核心属性" id="markdown-toc-核心属性">核心属性</a></li>
          <li><a href="#线程池状态变换图" id="markdown-toc-线程池状态变换图">线程池状态变换图</a></li>
          <li><a href="#构造函数" id="markdown-toc-构造函数">构造函数</a></li>
        </ul>
      </li>
      <li><a href="#二正常运行" id="markdown-toc-二正常运行">二、正常运行</a>        <ul>
          <li><a href="#execute" id="markdown-toc-execute">Execute()</a></li>
          <li><a href="#addworker" id="markdown-toc-addworker">addWorker()</a></li>
          <li><a href="#worker内部类" id="markdown-toc-worker内部类">Worker内部类</a></li>
          <li><a href="#runworker" id="markdown-toc-runworker">RunWorker()</a></li>
          <li><a href="#gettask" id="markdown-toc-gettask">getTask()</a></li>
        </ul>
      </li>
      <li><a href="#三线程池关闭" id="markdown-toc-三线程池关闭">三、线程池关闭</a>        <ul>
          <li><a href="#shutdown" id="markdown-toc-shutdown">shutdown()</a></li>
          <li><a href="#shutdownnow" id="markdown-toc-shutdownnow">shutdownNow()</a></li>
          <li><a href="#processworkerexit" id="markdown-toc-processworkerexit">processWorkerExit()</a></li>
          <li><a href="#tryterminate" id="markdown-toc-tryterminate">tryTerminate()</a></li>
        </ul>
      </li>
      <li><a href="#reject" id="markdown-toc-reject">reject()</a></li>
      <li><a href="#钩子方法分析" id="markdown-toc-钩子方法分析">钩子方法分析</a></li>
      <li><a href="#其他方法" id="markdown-toc-其他方法">其他方法</a></li>
      <li><a href="#小结" id="markdown-toc-小结">小结</a></li>
    </ul>
  </li>
</ul>
<p><img src="https://pic.tyzhang.top/images/2020/09/18/ThreadPoolExecutor.png" alt="ThreadPoolExecutor.png" /></p>

<h1 id="线程池参数">线程池参数</h1>

<p>线程池中的参数：</p>

<ul>
  <li>
    <p>核心线程数：线程池中常驻的线程数，核心线程在启动以后就会一直运行，即使没有任务</p>
  </li>
  <li>
    <p>最大线程数：当核心线程都被占用，阻塞队列也已经满的时候，就会新建额外的线程进行处理任务，但是新建的线程数要小于最大线程数</p>
  </li>
  <li>
    <p>线程存活时间：当额外的线程没有任务时，线程保留的时间</p>
  </li>
  <li>
    <p>存活时间单位：存活时间的单位</p>
  </li>
  <li>
    <p>任务队列：当任务来不及处理的时候，就会被放进任务队列。</p>
  </li>
  <li>
    <p>线程工厂： 创建线程的工厂</p>
  </li>
  <li>
    <p>拒绝策略： 当线程已经达到了最大线程数且任务队列也已经满了，那么就会执行拒绝策略，默认是抛出异常。</p>
  </li>
</ul>

<p>其实也就是ThreadPoolExecutor的构造函数的参数。</p>

<h1 id="继承关系">继承关系</h1>

<p><img src="https://pic.tyzhang.top/images/2020/09/18/ThreadPoolExtent.png" alt="ThreadPoolExtent.png" /></p>

<h1 id="exexutors">Exexutors</h1>

<p>一般来说都是使用ExecutorService接口进行操作线程池，但是具体的线程池代码是在ThreadPoolExecutor上进行执行。其中Executor源码定义了线程池的最主要的接口，如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Executor</span> <span class="o">{</span>

    <span class="cm">/**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     *
     * @param command the runnable task
     * @throws RejectedExecutionException if this task cannot be
     * accepted for execution
     * @throws NullPointerException if command is null
     */</span>
    <span class="c1">// 一般提交不带有返回值的都是 使用这个接口。</span>
    <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>不管是提交Runable接口还是提交Callable接口，都会使用这个接口进行完成任务。</p>

<h1 id="executorservice">ExecutorService</h1>

<p>在线程池中，不管是定义的Callable还是Runable，Runable是最主要的。对于ExecutorService接口来说如下：它定义了线程池应该有的功能和接口和扩展了带有返回值的submit方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ExecutorService</span> <span class="kd">extends</span> <span class="nc">Executor</span> <span class="o">{</span>
    <span class="c1">// 关闭操作、</span>
    <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">();</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="nf">shutdownNow</span><span class="o">();</span>

    <span class="kt">boolean</span> <span class="nf">isShutdown</span><span class="o">();</span>

    <span class="kt">boolean</span> <span class="nf">isTerminated</span><span class="o">();</span>

    <span class="kt">boolean</span> <span class="nf">awaitTermination</span><span class="o">(</span><span class="kt">long</span> <span class="n">var1</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">var3</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">;</span>
	
    <span class="c1">// 提交一个带有返回值的数据</span>
    <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">var1</span><span class="o">);</span>

    <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">var1</span><span class="o">,</span> <span class="no">T</span> <span class="n">var2</span><span class="o">);</span>

    <span class="nc">Future</span><span class="o">&lt;?&gt;</span> <span class="n">submit</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">var1</span><span class="o">);</span>

    <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="nf">invokeAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">var1</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">;</span>

    <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="nf">invokeAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">var4</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">;</span>

    <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">invokeAny</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">var1</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">ExecutionException</span><span class="o">;</span>

    <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">invokeAny</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">var4</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">TimeoutException</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>对于AbstractExecutorService来说，主要是实现了一个submit方法，可以发现都是使用new FutureTask( )这个类进行实现的。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Future</span><span class="o">&lt;?&gt;</span> <span class="n">submit</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">var1</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">var1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">RunnableFuture</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">newTaskFor</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="o">(</span><span class="nc">Object</span><span class="o">)</span><span class="kc">null</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">var2</span><span class="o">);</span> <span class="c1">// 可以发现，对于Future来说，也是使用execute()方法进行执行。。</span>
        <span class="k">return</span> <span class="n">var2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">var1</span><span class="o">,</span> <span class="no">T</span> <span class="n">var2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">var1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">RunnableFuture</span> <span class="n">var3</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">newTaskFor</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">var3</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">var3</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">RunnableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">newTaskFor</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">var1</span><span class="o">,</span> <span class="no">T</span> <span class="n">var2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">FutureTask</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">);</span> <span class="c1">//FutureTask 是一个Future的具体实现类，那么是怎么</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">RunnableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">newTaskFor</span><span class="o">(</span><span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">var1</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">FutureTask</span><span class="o">(</span><span class="n">var1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从上面可以发现，对于future任务来说，也是被execute进行执行，他被封装成了一个RunableFuture类型传递给execute方法中，</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RunnableFuture</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Runnable</span><span class="o">,</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="cm">/**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */</span>
    <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这样就只需要封装一个execute方法就行，那么为什么可以通过一个execute() 方法执行Callable()接口的方法呢？ 主要是因为Callable接口的方法还是依赖于Run()接口的运行，当提交一个Callable接口的任务后，首先他会被封装成一个FutureTask()任务类，在FutureTask中，使用run方法调用call方法，并且FutureTask中会使用一个内部属性保存call方法的返回值，那么就可以使用Future中的get方法获取到这个属性的值，也符合我们的get set方法，只不过set方法是在FutureTask内部进行自动的设置，另外为什么调用Future会被阻塞？ 因为在获取的时候会判断当前的状态值，如果没有达到完成状态，那么就会调用cas将自己添加到等待队列，这样其实也就是解释了当初socket为什么会等待队列，以及是怎么实现的，直接定义一个Thread类型就可以获取一个Thread，很神奇。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">WaitNode</span> <span class="o">{</span>
    <span class="kd">volatile</span> <span class="nc">Thread</span> <span class="n">thread</span><span class="o">;</span>
    <span class="kd">volatile</span> <span class="nc">WaitNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">WaitNode</span><span class="o">()</span> <span class="o">{</span> <span class="n">thread</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>线程也好，其他也好都只是方法的调用，因为Thread类已经封装好了，也是一个具体的执行者与代码之间的关系，所以有时候理解起来比较抽象，但是具体底层也都是run方法的重载和互相调用。然后又会被封装成一个RunableFuture任务类，这里面有run()方法，</p>

<p><img src="https://pic.tyzhang.top/images/2020/09/18/CallableAndRunable.png" alt="CallableAndRunable.png" /></p>

<h1 id="threadpoolexecutor">ThreadPoolExecutor</h1>

<h2 id="一属性知识">一、属性知识</h2>

<h3 id="核心属性">核心属性</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// AtomicInteger是原子类  ctlOf()返回值为RUNNING；</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">AtomicInteger</span> <span class="n">ctl</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="n">ctlOf</span><span class="o">(</span><span class="no">RUNNING</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
<span class="c1">// 高3位表示线程状态</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">COUNT_BITS</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">SIZE</span> <span class="o">-</span> <span class="mi">3</span><span class="o">;</span>  <span class="c1">// = 29</span>
<span class="c1">// 低29位表示workerCount容量</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">CAPACITY</span>   <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

<span class="c1">// runState is stored in the high-order bits</span>
<span class="c1">// 能接收任务且能处理阻塞队列中的任务</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">RUNNING</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="mi">1110</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span>  <span class="c1">// 最改为的三位都是 111 表示为 RUNNING</span>

<span class="c1">// 不能接收新任务，但可以处理队列中的任务。</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SHUTDOWN</span>   <span class="o">=</span>  <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="mo">000</span>
    
<span class="c1">// 不接收新任务，不处理队列任务。</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">STOP</span>       <span class="o">=</span>  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="mo">001</span>

<span class="c1">// 所有任务都终止</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TIDYING</span>    <span class="o">=</span>  <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="mo">010</span>

<span class="c1">// 什么都不做</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TERMINATED</span> <span class="o">=</span>  <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="mo">011</span>
    
<span class="c1">// 存放任务的阻塞队列</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">BlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">workQueue</span><span class="o">;</span>

<span class="kd">private</span> <span class="kd">final</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Worker</span><span class="o">&gt;</span> <span class="n">workers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Worker</span><span class="o">&gt;();</span> <span class="c1">// worker集合。</span>

<span class="kd">private</span> <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span> <span class="c1">// 为了进行同步使用hashset。 还有进行一些其他更改属性的操作需要。因为是使用cas所以不会阻塞进程。</span>

<span class="kd">private</span> <span class="kd">final</span> <span class="nc">Condition</span> <span class="n">termination</span> <span class="o">=</span> <span class="n">mainLock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</code></pre></div></div>

<p>线程池状态变换：</p>

<table>
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">RUNNING</code></th>
      <th><code class="language-plaintext highlighter-rouge">111-00000000000000000000000000000</code></th>
      <th>-536870912</th>
      <th>运行中状态，可以接收新的任务和执行任务队列中的任务</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SHUTDOWN</code></td>
      <td><code class="language-plaintext highlighter-rouge">000-00000000000000000000000000000</code></td>
      <td>0</td>
      <td>shutdown状态，不再接收新的任务，但是会执行任务队列中的任务</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">STOP</code></td>
      <td><code class="language-plaintext highlighter-rouge">001-00000000000000000000000000000</code></td>
      <td>536870912</td>
      <td>停止状态，不再接收新的任务，也不会执行任务队列中的任务，中断所有执行中的任务</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">TIDYING</code></td>
      <td><code class="language-plaintext highlighter-rouge">010-00000000000000000000000000000</code></td>
      <td>1073741824</td>
      <td>整理中状态，所有任务已经终结，工作线程数为0，过渡到此状态的工作线程会调用钩子方法<code class="language-plaintext highlighter-rouge">terminated()</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">TERMINATED</code></td>
      <td><code class="language-plaintext highlighter-rouge">011-00000000000000000000000000000</code></td>
      <td>1610612736</td>
      <td>终结状态，钩子方法<code class="language-plaintext highlighter-rouge">terminated()</code>执行完毕</td>
    </tr>
  </tbody>
</table>

<h3 id="线程池状态变换图">线程池状态变换图</h3>

<p><img src="https://pic.tyzhang.top/images/2020/09/18/PoolStateConvert.png" alt="PoolStateConvert.png" /></p>

<h3 id="构造函数">构造函数</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span><span class="c1">//线程池初始启动时线程的数量</span>
                          <span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">,</span><span class="c1">//最大线程数量</span>
                          <span class="kt">long</span> <span class="n">keepAliveTime</span><span class="o">,</span><span class="c1">//空闲线程多久关闭?</span>
                          <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">,</span><span class="c1">// 计时单位</span>
                          <span class="nc">BlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">workQueue</span><span class="o">,</span><span class="c1">//放任务的阻塞队列</span>
                          <span class="nc">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">,</span><span class="c1">//线程工厂</span>
                          <span class="nc">RejectedExecutionHandler</span> <span class="n">handler</span><span class="c1">// 拒绝策略) {</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">corePoolSize</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
        <span class="n">maximumPoolSize</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
        <span class="n">maximumPoolSize</span> <span class="o">&lt;</span> <span class="n">corePoolSize</span> <span class="o">||</span>
        <span class="n">keepAliveTime</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workQueue</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">threadFactory</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">handler</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">acc</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
            <span class="kc">null</span> <span class="o">:</span>
            <span class="nc">AccessController</span><span class="o">.</span><span class="na">getContext</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">corePoolSize</span> <span class="o">=</span> <span class="n">corePoolSize</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">maximumPoolSize</span> <span class="o">=</span> <span class="n">maximumPoolSize</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">workQueue</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">keepAliveTime</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">keepAliveTime</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">threadFactory</span> <span class="o">=</span> <span class="n">threadFactory</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>线程池中的参数：</p>

<ul>
  <li>核心线程数：线程池中常驻的线程数，核心线程在启动以后就会一直运行，即使没有任务</li>
  <li>最大线程数：当核心线程都被占用，阻塞队列也已经满的时候，就会新建额外的线程进行处理任务，但是新建的线程数要小于最大线程数</li>
  <li>线程存活时间：当额外的线程没有任务时，线程保留的时间</li>
  <li>存活时间单位：存活时间的单位</li>
  <li>任务队列：当任务来不及处理的时候，就会被放进任务队列。</li>
  <li>线程工厂： 创建线程的工厂</li>
  <li>拒绝策略： 当线程已经达到了最大线程数且任务队列也已经满了，那么就会执行拒绝策略，默认是抛出异常。
    <ul>
      <li><code class="language-plaintext highlighter-rouge">AbortPolicy</code>：直接拒绝策略，也就是不会执行任务，直接抛出<code class="language-plaintext highlighter-rouge">RejectedExecutionException</code>，这是<strong>默认的拒绝策略</strong>。</li>
      <li><code class="language-plaintext highlighter-rouge">DiscardPolicy</code>：抛弃策略，也就是直接忽略提交的任务（通俗来说就是空实现）。</li>
      <li><code class="language-plaintext highlighter-rouge">DiscardOldestPolicy</code>：抛弃最老任务策略，也就是通过<code class="language-plaintext highlighter-rouge">poll()</code>方法取出任务队列队头的任务抛弃，然后执行当前提交的任务。</li>
      <li><code class="language-plaintext highlighter-rouge">CallerRunsPolicy</code>：调用者执行策略，也就是当前调用<code class="language-plaintext highlighter-rouge">Executor#execute()</code>的线程直接调用任务<code class="language-plaintext highlighter-rouge">Runnable#run()</code>，<strong>一般不希望任务丢失会选用这种策略，但从实际角度来看，原来的异步调用意图会退化为同步调用</strong>。</li>
    </ul>
  </li>
</ul>

<p>构建<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>实例的时候，需要定义<code class="language-plaintext highlighter-rouge">maximumPoolSize</code>（线程池最大线程数）和<code class="language-plaintext highlighter-rouge">corePoolSize</code>（核心线程数）。当任务队列是有界的阻塞队列，核心线程满负载，任务队列已经满的情况下，会尝试创建额外的<code class="language-plaintext highlighter-rouge">maximumPoolSize - corePoolSize</code>个线程去执行新提交的任务。当<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>这里实现的两个主要附加功能是：</p>

<ul>
  <li>一定条件下会创建非核心线程去执行任务，非核心线程的回收周期（线程生命周期终结时刻）是<code class="language-plaintext highlighter-rouge">keepAliveTime</code>，线程生命周期终结的条件是：下一次通过任务队列获取任务的时候并且存活时间超过<code class="language-plaintext highlighter-rouge">keepAliveTime</code>。</li>
  <li>提供拒绝策略，也就是在核心线程满负载、任务队列已满、非核心线程满负载的条件下会触发拒绝策略。</li>
</ul>

<h2 id="二正常运行">二、正常运行</h2>

<h3 id="execute">Execute()</h3>

<p>execute()方法为整个线程池的核心方法，所有的Runable和Callable任务的都是由这个接口进行运行和实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 执行命令，其中命令（下面称任务）对象是Runnable的实例</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 判断命令（任务）对象非空</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">command</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="c1">// 获取ctl的值， 也就是状态码和记录工作线程个数的值。</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="c1">// 判断如果当前工作线程数小于核心线程数，则创建新的核心线程并且执行传入的任务 workerCountOf(c) </span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
            <span class="c1">// 如果创建新的核心线程成功则直接返回</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="c1">// 这里说明创建核心线程失败，需要更新ctl的临时变量c</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 走到这里说明创建新的核心线程失败，也就是当前工作线程数大于等于corePoolSize</span>
    <span class="c1">// 判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务（放入任务失败返回false）</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">command</span><span class="o">))</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">recheck</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="c1">// 这里是向任务队列投放任务成功，对线程池的运行中状态做二次检查</span>
        <span class="c1">// 如果线程池二次检查状态是非运行中状态，则从任务队列移除当前的任务调用拒绝策略处理之（也就是移除前面成功入队的任务实例）</span>
        <span class="k">if</span> <span class="o">(!</span> <span class="n">isRunning</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">remove</span><span class="o">(</span><span class="n">command</span><span class="o">))</span>
            <span class="c1">// 调用拒绝策略处理任务 - 返回</span>
            <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
        <span class="c1">// 走到下面的else if分支，说明有以下的前提：</span>
        <span class="c1">// 0、待执行的任务已经成功加入任务队列</span>
        <span class="c1">// 1、线程池可能是RUNNING状态</span>
        <span class="c1">// 2、传入的任务可能从任务队列中移除失败（移除失败的唯一可能就是任务已经被执行了）</span>
        <span class="c1">// 如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null - 返回</span>
        <span class="c1">// 也就是创建的非核心线程不会马上运行，而是等待获取任务队列的任务去执行 </span>
        <span class="c1">// 如果前工作线程数量不为0，原来应该是最后的else分支，但是可以什么也不做，因为任务已经成功入队列，总会有合适的时机分配其他空闲线程去执行它</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 走到这里说明有以下的前提：</span>
    <span class="c1">// 0、线程池中的工作线程总数已经大于等于corePoolSize（简单来说就是核心线程已经全部懒创建完毕）</span>
    <span class="c1">// 1、线程池可能不是RUNNING状态</span>
    <span class="c1">// 2、线程池可能是RUNNING状态同时任务队列已经满了</span>
    <span class="c1">// 如果向任务队列投放任务失败，则会尝试创建非核心线程传入任务执行</span>
    <span class="c1">// 创建非核心线程失败，此时需要拒绝执行任务</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span>
        <span class="c1">// 调用拒绝策略处理任务 - 返回</span>
        <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里简单分析一下整个流程：</p>

<ol>
  <li>如果当前工作线程总数小于<code class="language-plaintext highlighter-rouge">corePoolSize</code>，则直接创建核心线程执行任务（任务实例会传入直接用于构造工作线程实例）。</li>
  <li>如果当前工作线程总数大于等于<code class="language-plaintext highlighter-rouge">corePoolSize</code>，判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务，这里会二次检查线程池运行状态，如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null。</li>
  <li>如果向任务队列投放任务失败（任务队列已经满了），则会尝试创建非核心线程传入任务实例执行。</li>
  <li>如果创建非核心线程失败，此时需要拒绝执行任务，调用拒绝策略处理任务。</li>
</ol>

<p><strong>这里是一个疑惑点</strong>：为什么需要二次检查线程池的运行状态，当前工作线程数量为0，尝试创建一个非核心线程并且传入的任务对象为null？这个可以看API注释：</p>

<blockquote>
  <p>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程（因为所有存活的工作线程有可能在最后一次检查之后已经终结）或者执行当前方法的时候线程池是否已经shutdown了。所以我们需要二次检查线程池的状态，必须时把任务从任务队列中移除或者在没有可用的工作线程的前提下新建一个工作线程。</p>
</blockquote>

<p>任务提交流程从调用者的角度来看如下：</p>

<p><img src="https://pic.tyzhang.top/images/2020/09/18/ExecuteFlow.png" alt="ExecuteFlow.png" /></p>

<h3 id="addworker">addWorker()</h3>

<p>当核心线程不够的时候，需要进行添加工人线程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 添加工作线程，如果返回false说明没有新创建工作线程，如果返回true说明创建和启动工作线程成功</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">addWorker</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">firstTask</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">core</span><span class="o">)</span> <span class="o">{</span>
    <span class="nl">retry:</span>  
    <span class="c1">// 注意这是一个死循环 - 最外层循环</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();;)</span> <span class="o">{</span>
        <span class="c1">// 这个是十分复杂的条件，这里先拆分多个与（&amp;&amp;）条件：</span>
        <span class="c1">// 1. 线程池状态至少为SHUTDOWN状态，也就是rs &gt;= SHUTDOWN(0)</span>
        <span class="c1">// 2. 线程池状态至少为STOP状态，也就是rs &gt;= STOP(1)，或者传入的任务实例firstTask不为null，或者任务队列为空</span>
        <span class="c1">// 其实这个判断的边界是线程池状态为shutdown状态下，不会再接受新的任务，在此前提下如果状态已经到了STOP、或者传入任务不为空、或者任务队列为空（已经没有积压任务）都不需要添加新的线程</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">SHUTDOWN</span><span class="o">)</span>
            <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">STOP</span><span class="o">)</span>
                <span class="o">||</span> <span class="n">firstTask</span> <span class="o">!=</span> <span class="kc">null</span>
                <span class="o">||</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">// 注意这也是一个死循环 - 二层循环</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="c1">// 这里每一轮循环都会重新获取工作线程数wc</span>
            <span class="c1">// 1. 如果传入的core为true，表示将要创建核心线程，通过wc和corePoolSize判断，如果wc &gt;= corePoolSize，则返回false表示创建核心线程失败</span>
            <span class="c1">// 1. 如果传入的core为false，表示将要创非建核心线程，通过wc和maximumPoolSize判断，如果wc &gt;= maximumPoolSize，则返回false表示创建非核心线程失败</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
                <span class="o">&gt;=</span> <span class="o">((</span><span class="n">core</span> <span class="o">?</span> <span class="n">corePoolSize</span> <span class="o">:</span> <span class="n">maximumPoolSize</span><span class="o">)</span> <span class="o">&amp;</span> <span class="no">COUNT_MASK</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="c1">// 成功通过CAS更新工作线程数wc，则break到最外层的循环</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndIncrementWorkerCount</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
                <span class="k">break</span> <span class="n">retry</span><span class="o">;</span>
            <span class="c1">// 走到这里说明了通过CAS更新工作线程数wc失败，这个时候需要重新判断线程池的状态是否由RUNNING已经变为SHUTDOWN</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  <span class="c1">// Re-read ctl</span>
            <span class="c1">// 如果线程池状态已经由RUNNING已经变为SHUTDOWN，则重新跳出到外层循环继续执行</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">SHUTDOWN</span><span class="o">))</span>
                <span class="k">continue</span> <span class="n">retry</span><span class="o">;</span>
            <span class="c1">// 如果线程池状态依然是RUNNING，CAS更新工作线程数wc失败说明有可能是并发更新导致的失败，则在内层循环重试即可 </span>
            <span class="c1">// else CAS failed due to workerCount change; retry inner loop </span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 标记工作线程是否启动成功</span>
    <span class="kt">boolean</span> <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="c1">// 标记工作线程是否创建成功</span>
    <span class="kt">boolean</span> <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">Worker</span> <span class="n">w</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 传入任务实例firstTask创建Worker实例，Worker构造里面会通过线程工厂创建新的Thread对象，所以下面可以直接操作Thread t = w.thread</span>
        <span class="c1">// 这一步Worker实例已经创建，但是没有加入工作线程集合或者启动它持有的线程Thread实例</span>
        <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Worker</span><span class="o">(</span><span class="n">firstTask</span><span class="o">);</span>
        <span class="kd">final</span> <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">thread</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 这里需要全局加锁，因为会改变一些指标值和非线程安全的集合</span>
            <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
            <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// Recheck while holding lock.</span>
                <span class="c1">// Back out on ThreadFactory failure or if</span>
                <span class="c1">// shut down before lock acquired.</span>
                <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                <span class="c1">// 这里主要在加锁的前提下判断ThreadFactory创建的线程是否存活或者判断获取锁成功之后线程池状态是否已经更变为SHUTDOWN</span>
                <span class="c1">// 1. 如果线程池状态依然为RUNNING，则只需要判断线程实例是否存活，需要添加到工作线程集合和启动新的Worker</span>
                <span class="c1">// 2. 如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span>
                <span class="c1">// 对于2，换言之，如果线程池处于SHUTDOWN状态下，同时传入的任务实例firstTask不为null，则不会添加到工作线程集合和启动新的Worker</span>
                <span class="c1">// 这一步其实有可能创建了新的Worker实例但是并不启动（临时对象，没有任何强引用），这种Worker有可能成功下一轮GC被收集的垃圾对象</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">runStateLessThan</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">STOP</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">firstTask</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">isAlive</span><span class="o">())</span> <span class="c1">// precheck that t is startable</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalThreadStateException</span><span class="o">();</span>
                    <span class="c1">// 把创建的工作线程实例添加到工作线程集合</span>
                    <span class="n">workers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">workers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
                    <span class="c1">// 尝试更新历史峰值工作线程数，也就是线程池峰值容量</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">largestPoolSize</span><span class="o">)</span>
                        <span class="n">largestPoolSize</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                    <span class="c1">// 这里更新工作线程是否启动成功标识为true，后面才会调用Thread#start()方法启动真实的线程实例</span>
                    <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">workerAdded</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 启动线程。</span>
                <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
                <span class="c1">// 标记线程启动成功</span>
                <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">// 线程启动失败，需要从工作线程集合移除对应的Worker</span>
        <span class="k">if</span> <span class="o">(!</span> <span class="n">workerStarted</span><span class="o">)</span>
            <span class="n">addWorkerFailed</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">workerStarted</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 添加Worker失败</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">addWorkerFailed</span><span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 从工作线程集合移除之</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">workers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
        <span class="c1">// wc数量减1    </span>
        <span class="n">decrementWorkerCount</span><span class="o">();</span>
        <span class="c1">// 基于状态判断尝试终结线程池</span>
        <span class="n">tryTerminate</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>笔者发现了<code class="language-plaintext highlighter-rouge">Doug Lea</code>大神十分喜欢复杂的条件判断，而且单行复杂判断不喜欢加花括号，像下面这种代码在他编写的很多类库中都比较常见：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">SHUTDOWN</span><span class="o">)</span>
    <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">STOP</span><span class="o">)</span>
        <span class="o">||</span> <span class="n">firstTask</span> <span class="o">!=</span> <span class="kc">null</span>
        <span class="o">||</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="c1">// ....</span>
<span class="c1">//  代码拆分一下如下 </span>
<span class="kt">boolean</span> <span class="n">atLeastShutdown</span> <span class="o">=</span> <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">SHUTDOWN</span><span class="o">);</span>     <span class="err">#</span> <span class="n">rs</span> <span class="o">&gt;=</span> <span class="no">SHUTDOWN</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="kt">boolean</span> <span class="n">atLeastStop</span> <span class="o">=</span> <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">STOP</span><span class="o">)</span> <span class="o">||</span> <span class="n">firstTask</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>     
<span class="k">if</span> <span class="o">(</span><span class="n">atLeastShutdown</span> <span class="o">&amp;&amp;</span> <span class="n">atLeastStop</span><span class="o">){</span>
   <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面的分析逻辑中需要注意一点，<code class="language-plaintext highlighter-rouge">Worker</code>实例创建的同时，在其构造函数中会通过<code class="language-plaintext highlighter-rouge">ThreadFactory</code>创建一个Java线程<code class="language-plaintext highlighter-rouge">Thread</code>实例，后面会加锁后二次检查是否需要把<code class="language-plaintext highlighter-rouge">Worker</code>实例添加到工作线程集合<code class="language-plaintext highlighter-rouge">workers</code>中和是否需要启动<code class="language-plaintext highlighter-rouge">Worker</code>中持有的<code class="language-plaintext highlighter-rouge">Thread</code>实例，只有启动了<code class="language-plaintext highlighter-rouge">Thread</code>实例实例，<code class="language-plaintext highlighter-rouge">Worker</code>才真正开始运作，否则只是一个无用的临时对象。<code class="language-plaintext highlighter-rouge">Worker</code>本身也实现了<code class="language-plaintext highlighter-rouge">Runnable</code>接口，它可以看成是一个<code class="language-plaintext highlighter-rouge">Runnable</code>的适配器。</p>

<h3 id="worker内部类">Worker内部类</h3>

<p>线程池中的每一个具体的工作线程被包装为内部类<code class="language-plaintext highlighter-rouge">Worker</code>实例，<code class="language-plaintext highlighter-rouge">Worker</code>继承于<code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer(AQS)</code>，实现了<code class="language-plaintext highlighter-rouge">Runnable</code>接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Worker</span> <span class="kd">extends</span> <span class="nc">AbstractQueuedSynchronizer</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="cm">/**
        * This class will never be serialized, but we provide a
        * serialVersionUID to suppress a javac warning.
        */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">6138294804551838833L</span><span class="o">;</span>

    <span class="c1">// 保存ThreadFactory创建的线程实例，如果ThreadFactory创建线程失败则为null</span>
    <span class="kd">final</span> <span class="nc">Thread</span> <span class="n">thread</span><span class="o">;</span>
    <span class="c1">// 保存传入的Runnable任务实例</span>
    <span class="nc">Runnable</span> <span class="n">firstTask</span><span class="o">;</span>
    <span class="c1">// 记录每个线程完成的任务总数</span>
    <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">completedTasks</span><span class="o">;</span>
    
    <span class="c1">// 唯一的构造函数，传入任务实例firstTask，注意可以为null</span>
    <span class="nc">Worker</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">firstTask</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 禁止线程中断，直到runWorker()方法执行</span>
        <span class="n">setState</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// inhibit interrupts until runWorker</span>
        <span class="k">this</span><span class="o">.</span><span class="na">firstTask</span> <span class="o">=</span> <span class="n">firstTask</span><span class="o">;</span>
        <span class="c1">// 通过ThreadFactory创建线程实例，注意一下Worker实例自身作为Runnable用于创建新的线程实例</span>
        <span class="k">this</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">getThreadFactory</span><span class="o">().</span><span class="na">newThread</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 委托到外部的runWorker()方法，注意runWorker()方法是线程池的方法，而不是Worker的方法</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">runWorker</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Lock methods</span>
    <span class="c1">//</span>
    <span class="c1">// The value 0 represents the unlocked state.</span>
    <span class="c1">// The value 1 represents the locked state.</span>
    <span class="c1">//  是否持有独占锁，state值为1的时候表示持有锁，state值为0的时候表示已经释放锁</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
	
    <span class="c1">// 加锁为 1  解锁设置为0 </span>
    
    <span class="c1">// 独占模式下尝试获取资源，这里没有判断传入的变量，直接CAS判断0更新为1是否成功，成功则设置独占线程为当前线程</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">unused</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 独占模式下尝试是否资源，这里没有判断传入的变量，直接把state设置为0</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">unused</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">setState</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 加锁</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span>        <span class="o">{</span> <span class="n">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="o">}</span> <span class="c1">// 调用的也是tryacquire()</span>

    <span class="c1">// 尝试加锁</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="o">}</span>

    <span class="c1">// 解锁</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span>      <span class="o">{</span> <span class="n">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="o">}</span>

    <span class="c1">// 是否锁定</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">isHeldExclusively</span><span class="o">();</span> <span class="o">}</span>
    
    <span class="c1">// 启动后进行线程中断，注意这里会判断线程实例的中断标志位是否为false，只有中断标志位为false才会中断</span>
    <span class="kt">void</span> <span class="nf">interruptIfStarted</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getState</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">thread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SecurityException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Worker</code>的构造函数里面的逻辑十分重要，通过<code class="language-plaintext highlighter-rouge">ThreadFactory</code>创建的<code class="language-plaintext highlighter-rouge">Thread</code>实例同时传入<code class="language-plaintext highlighter-rouge">Worker</code>实例，因为<code class="language-plaintext highlighter-rouge">Worker</code>本身实现了<code class="language-plaintext highlighter-rouge">Runnable</code>，所以可以作为任务提交到线程中执行。只要<code class="language-plaintext highlighter-rouge">Worker</code>持有的线程实例<code class="language-plaintext highlighter-rouge">w</code>调用<code class="language-plaintext highlighter-rouge">Thread#start()</code>方法就能在合适时机执行<code class="language-plaintext highlighter-rouge">Worker#run()</code>。简化一下逻辑如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// addWorker()方法中构造</span>
<span class="nc">Worker</span> <span class="n">worker</span> <span class="o">=</span> <span class="n">createWorker</span><span class="o">();</span>
<span class="c1">// 通过线程池构造时候传入</span>
<span class="nc">ThreadFactory</span> <span class="n">threadFactory</span> <span class="o">=</span> <span class="n">getThreadFactory</span><span class="o">();</span>
<span class="c1">// Worker构造函数中</span>
<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">threadFactory</span><span class="o">.</span><span class="na">newThread</span><span class="o">(</span><span class="n">worker</span><span class="o">);</span>
<span class="c1">// addWorker()方法中启动</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Worker</code>继承自<code class="language-plaintext highlighter-rouge">AQS</code>，这里使用了<code class="language-plaintext highlighter-rouge">AQS</code>的独占模式，有个技巧是构造<code class="language-plaintext highlighter-rouge">Worker</code>的时候，把<code class="language-plaintext highlighter-rouge">AQS</code>的资源（状态）通过<code class="language-plaintext highlighter-rouge">setState(-1)</code>设置为-1，这是因为<code class="language-plaintext highlighter-rouge">Worker</code>实例刚创建时<code class="language-plaintext highlighter-rouge">AQS</code>中<code class="language-plaintext highlighter-rouge">state</code>的默认值为0，此时线程尚未启动，不能在这个时候进行线程中断，见<code class="language-plaintext highlighter-rouge">Worker#interruptIfStarted()</code>方法。<code class="language-plaintext highlighter-rouge">Worker</code>中两个覆盖<code class="language-plaintext highlighter-rouge">AQS</code>的方法<code class="language-plaintext highlighter-rouge">tryAcquire()</code>和<code class="language-plaintext highlighter-rouge">tryRelease()</code>都没有判断外部传入的变量，前者直接<code class="language-plaintext highlighter-rouge">CAS(0,1)</code>，后者直接<code class="language-plaintext highlighter-rouge">setState(0)</code>。</p>

<h3 id="runworker">RunWorker()</h3>

<p>接着看核心方法<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor#runWorker()</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">void</span> <span class="nf">runWorker</span><span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 获取当前线程，实际上和Worker持有的线程实例是相同的</span>
    <span class="nc">Thread</span> <span class="n">wt</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="c1">// 获取Worker中持有的初始化时传入的任务对象，这里注意存放在临时变量task中</span>
    <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">firstTask</span><span class="o">;</span>
    <span class="c1">// 设置Worker中持有的初始化时传入的任务对象为null</span>
    <span class="n">w</span><span class="o">.</span><span class="na">firstTask</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 由于Worker初始化时AQS中state设置为-1，这里要先做一次解锁把state更新为0，允许线程中断</span>
    <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">// allow interrupts</span>
    <span class="c1">// 记录线程是否因为用户异常终结，默认是true</span>
    <span class="kt">boolean</span> <span class="n">completedAbruptly</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 初始化任务对象不为null，或者从任务队列获取任务不为空（从任务队列获取到的任务会更新到临时变量task中）</span>
        <span class="c1">// getTask()由于使用了阻塞队列，这个while循环如果命中后半段会处于阻塞或者超时阻塞状态，getTask()返回为null会导致线程跳出死循环使线程终结</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">task</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">task</span> <span class="o">=</span> <span class="n">getTask</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Worker加锁，本质是AQS获取资源并且尝试CAS更新state由0更变为1</span>
            <span class="n">w</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="c1">// If pool is stopping, ensure thread is interrupted;</span>
            <span class="c1">// if not, ensure thread is not interrupted.  This</span>
            <span class="c1">// requires a recheck in second case to deal with</span>
            <span class="c1">// shutdownNow race while clearing interrupt</span>
            <span class="c1">// 如果线程池正在停止（也就是由RUNNING或者SHUTDOWN状态向STOP状态变更），那么要确保当前工作线程是中断状态</span>
            <span class="c1">// 否则，要保证当前线程不是中断状态</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">STOP</span><span class="o">)</span> <span class="o">||</span>
                    <span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
                    <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">STOP</span><span class="o">)))</span> <span class="o">&amp;&amp;</span>
                <span class="o">!</span><span class="n">wt</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">())</span>
                <span class="n">wt</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 钩子方法，任务执行前</span>
                <span class="n">beforeExecute</span><span class="o">(</span><span class="n">wt</span><span class="o">,</span> <span class="n">task</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">task</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
                    <span class="c1">// 钩子方法，任务执行后 - 正常情况</span>
                    <span class="n">afterExecute</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 钩子方法，任务执行后 - 异常情况</span>
                    <span class="n">afterExecute</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
                    <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="c1">// 清空task临时变量，这个很重要，否则while会死循环执行同一个task</span>
                <span class="n">task</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="c1">// 累加Worker完成的任务数</span>
                <span class="n">w</span><span class="o">.</span><span class="na">completedTasks</span><span class="o">++;</span>
                <span class="c1">// Worker解锁，本质是AQS释放资源，设置state为0</span>
                <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 走到这里说明某一次getTask()返回为null，线程正常退出</span>
        <span class="n">completedAbruptly</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">// 处理线程退出，completedAbruptly为true说明由于用户异常导致线程非正常退出</span>
        <span class="n">processWorkerExit</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">completedAbruptly</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里重点拆解分析一下判断当前工作线程中断状态的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">((</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">STOP</span><span class="o">)</span> <span class="o">||</span>
        <span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">STOP</span><span class="o">)))</span> <span class="o">&amp;&amp;</span>
    <span class="o">!</span><span class="n">wt</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">())</span>
    <span class="n">wt</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
<span class="c1">// 先简化一下判断逻辑，如下</span>
<span class="c1">// 判断线程池状态是否至少为STOP，rs &gt;= STOP(1)</span>
<span class="kt">boolean</span> <span class="n">atLeastStop</span> <span class="o">=</span> <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">STOP</span><span class="o">);</span>
<span class="c1">// 判断线程池状态是否至少为STOP，同时判断当前线程的中断状态并且清空当前线程的中断状态</span>
<span class="kt">boolean</span> <span class="n">interruptedAndAtLeastStop</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">STOP</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">atLeastStop</span> <span class="o">||</span> <span class="n">interruptedAndAtLeastStop</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wt</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">()){</span>
    <span class="n">wt</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Thread.interrupted()</code>方法获取线程的中断状态同时会清空该中断状态，这里之所以会调用这个方法是因为在执行上面这个<code class="language-plaintext highlighter-rouge">if</code>逻辑同时外部有可能调用<code class="language-plaintext highlighter-rouge">shutdownNow()</code>方法，<code class="language-plaintext highlighter-rouge">shutdownNow()</code>方法中也存在中断所有<code class="language-plaintext highlighter-rouge">Worker</code>线程的逻辑，但是由于<code class="language-plaintext highlighter-rouge">shutdownNow()</code>方法中会遍历所有<code class="language-plaintext highlighter-rouge">Worker</code>做线程中断，有可能无法及时在任务提交到<code class="language-plaintext highlighter-rouge">Worker</code>执行之前进行中断，所以这个中断逻辑会在<code class="language-plaintext highlighter-rouge">Worker</code>内部执行，就是<code class="language-plaintext highlighter-rouge">if</code>代码块的逻辑。这里还要注意的是：<code class="language-plaintext highlighter-rouge">STOP</code>状态下会拒绝所有新提交的任务，不会再执行任务队列中的任务，同时会中断所有<code class="language-plaintext highlighter-rouge">Worker</code>线程。也就是，<strong>即使任务Runnable已经<code class="language-plaintext highlighter-rouge">runWorker()</code>中前半段逻辑取出，只要还没走到调用其Runnable#run()，都有可能被中断</strong>。假设刚好发生了进入<code class="language-plaintext highlighter-rouge">if</code>代码块的逻辑同时外部调用了<code class="language-plaintext highlighter-rouge">shutdownNow()</code>方法，那么<code class="language-plaintext highlighter-rouge">if</code>逻辑内会判断线程中断状态并且重置，那么<code class="language-plaintext highlighter-rouge">shutdownNow()</code>方法中调用的<code class="language-plaintext highlighter-rouge">interruptWorkers()</code>就不会因为中断状态判断出现问题导致二次中断线程（会导致异常）。</p>

<p>小结一下上面<code class="language-plaintext highlighter-rouge">runWorker()</code>方法的核心流程：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Worker</code>先执行一次解锁操作，用于解除不可中断状态。</li>
  <li>通过<code class="language-plaintext highlighter-rouge">while</code>循环调用<code class="language-plaintext highlighter-rouge">getTask()</code>方法从任务队列中获取任务（当然，首轮循环也有可能是外部传入的firstTask任务实例）。</li>
  <li>如果线程池更变为<code class="language-plaintext highlighter-rouge">STOP</code>状态，则需要确保工作线程是中断状态并且进行中断处理，否则要保证工作线程必须不是中断状态。</li>
  <li>执行任务实例<code class="language-plaintext highlighter-rouge">Runnale#run()</code>方法，任务实例执行之前和之后（包括正常执行完毕和异常执行情况）分别会调用钩子方法<code class="language-plaintext highlighter-rouge">beforeExecute()</code>和<code class="language-plaintext highlighter-rouge">afterExecute()</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">while</code>循环跳出意味着<code class="language-plaintext highlighter-rouge">runWorker()</code>方法结束和工作线程生命周期结束（<code class="language-plaintext highlighter-rouge">Worker#run()</code>生命周期完结），会调用<code class="language-plaintext highlighter-rouge">processWorkerExit()</code>处理工作线程退出的后续工作。</li>
</ol>

<p><img src="https://pic.tyzhang.top/images/2020/09/18/RunWokerFlow.png" alt="RunWokerFlow.png" /></p>

<p>接下来分析一下从任务队列中获取任务的<code class="language-plaintext highlighter-rouge">getTask()</code>方法和处理线程退出的后续工作的<code class="language-plaintext highlighter-rouge">processWorkerExit()</code>方法。</p>

<h3 id="gettask">getTask()</h3>

<p><code class="language-plaintext highlighter-rouge">getTask()</code>方法是工作线程在<code class="language-plaintext highlighter-rouge">while</code>死循环中获取任务队列中的任务对象的方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Runnable</span> <span class="nf">getTask</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 记录上一次从队列中拉取的时候是否超时</span>
    <span class="kt">boolean</span> <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Did the last poll() time out?</span>
    <span class="c1">// 注意这是死循环</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

        <span class="c1">// Check if queue empty only if necessary.</span>
        <span class="c1">// 第一个if：如果线程池状态至少为SHUTDOWN，也就是rs &gt;= SHUTDOWN(0)，则需要判断两种情况（或逻辑）：</span>
        <span class="c1">// 1. 线程池状态至少为STOP(1)，也就是线程池正在停止，一般是调用了shutdownNow()方法</span>
        <span class="c1">// 2. 任务队列为空</span>
        <span class="c1">// 如果在线程池至少为SHUTDOWN状态并且满足上面两个条件之一，则工作线程数wc减去1，然后直接返回null</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">SHUTDOWN</span><span class="o">)</span>
            <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">STOP</span><span class="o">)</span> <span class="o">||</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">decrementWorkerCount</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 跑到这里说明线程池还处于RUNNING状态，重新获取一次工作线程数</span>
        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

        <span class="c1">// Are workers subject to culling?</span>
        <span class="c1">// timed临时变量勇于线程超时控制，决定是否需要通过poll()此带超时的非阻塞方法进行任务队列的任务拉取</span>
        <span class="c1">// 1.allowCoreThreadTimeOut默认值为false，如果设置为true，则允许核心线程也能通过poll()方法从任务队列中拉取任务</span>
        <span class="c1">// 2.工作线程数大于核心线程数的时候，说明线程池中创建了额外的非核心线程，这些非核心线程一定是通过poll()方法从任务队列中拉取任务</span>
        <span class="kt">boolean</span> <span class="n">timed</span> <span class="o">=</span> <span class="n">allowCoreThreadTimeOut</span> <span class="o">||</span> <span class="n">wc</span> <span class="o">&gt;</span> <span class="n">corePoolSize</span><span class="o">;</span>
        <span class="c1">// 第二个if：</span>
        <span class="c1">// 1.wc &gt; maximumPoolSize说明当前的工作线程总数大于maximumPoolSize，说明了通过setMaximumPoolSize()方法减少了线程池容量</span>
        <span class="c1">// 或者 2.timed &amp;&amp; timedOut说明了线程命中了超时控制并且上一轮循环通过poll()方法从任务队列中拉取任务为null</span>
        <span class="c1">// 并且 3. 工作线程总数大于1或者任务队列为空，则通过CAS把线程数减去1，同时返回null，</span>
        <span class="c1">// CAS把线程数减去1失败会进入下一轮循环做重试</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">wc</span> <span class="o">&gt;</span> <span class="n">maximumPoolSize</span> <span class="o">||</span> <span class="o">(</span><span class="n">timed</span> <span class="o">&amp;&amp;</span> <span class="n">timedOut</span><span class="o">))</span>
            <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">wc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndDecrementWorkerCount</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 如果timed为true，通过poll()方法做超时拉取，keepAliveTime时间内没有等待到有效的任务，则返回null</span>
            <span class="c1">// 如果timed为false，通过take()做阻塞拉取，会阻塞到有下一个有效的任务时候再返回（一般不会是null）</span>
            <span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="n">timed</span> <span class="o">?</span>
                <span class="n">workQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">keepAliveTime</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">NANOSECONDS</span><span class="o">)</span> <span class="o">:</span>
                <span class="n">workQueue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
            <span class="c1">// 这里很重要，只有非null时候才返回，null的情况下会进入下一轮循环</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
            <span class="c1">// 跑到这里说明上一次从任务队列中获取到的任务为null，一般是workQueue.poll()方法超时返回null</span>
            <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">retry</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法中，有两处十分庞大的<code class="language-plaintext highlighter-rouge">if</code>逻辑，对于第一处<code class="language-plaintext highlighter-rouge">if</code>可能导致工作线程数减去1直接返回<code class="language-plaintext highlighter-rouge">null</code>的场景有：</p>

<ol>
  <li>线程池状态为<code class="language-plaintext highlighter-rouge">SHUTDOWN</code>，一般是调用了<code class="language-plaintext highlighter-rouge">shutdown()</code>方法，并且任务队列为空。</li>
  <li>线程池状态为<code class="language-plaintext highlighter-rouge">STOP</code>。</li>
</ol>

<p>对于第二处<code class="language-plaintext highlighter-rouge">if</code>，逻辑有点复杂，先拆解一下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 工作线程总数大于maximumPoolSize，说明了通过setMaximumPoolSize()方法减少了线程池容量</span>
<span class="kt">boolean</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">wc</span> <span class="o">&gt;</span> <span class="n">maximumPoolSize</span><span class="o">;</span>
<span class="c1">// 允许线程超时同时上一轮通过poll()方法从任务队列中拉取任务为null</span>
<span class="kt">boolean</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">timed</span> <span class="o">&amp;&amp;</span> <span class="n">timedOut</span><span class="o">;</span>
<span class="c1">// 工作线程总数大于1</span>
<span class="kt">boolean</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">wc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">;</span>
<span class="c1">// 任务队列为空</span>
<span class="kt">boolean</span> <span class="n">b4</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="n">b1</span> <span class="o">||</span> <span class="n">b2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">b3</span> <span class="o">||</span> <span class="n">b4</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">compareAndDecrementWorkerCount</span><span class="o">(</span><span class="n">c</span><span class="o">)){</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="k">continue</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这段逻辑大多数情况下是针对非核心线程。在<code class="language-plaintext highlighter-rouge">execute()</code>方法中，当线程池总数已经超过了<code class="language-plaintext highlighter-rouge">corePoolSize</code>并且还小于<code class="language-plaintext highlighter-rouge">maximumPoolSize</code>时，当任务队列已经满了的时候，会通过<code class="language-plaintext highlighter-rouge">addWorker(task,false)</code>添加非核心线程。而这里的逻辑恰好类似于<code class="language-plaintext highlighter-rouge">addWorker(task,false)</code>的反向操作，用于减少非核心线程，使得工作线程总数趋向于<code class="language-plaintext highlighter-rouge">corePoolSize</code>。如果对于非核心线程，上一轮循环获取任务对象为<code class="language-plaintext highlighter-rouge">null</code>，这一轮循环很容易满足<code class="language-plaintext highlighter-rouge">timed &amp;&amp; timedOut</code>为true，这个时候<code class="language-plaintext highlighter-rouge">getTask()</code>返回null会导致<code class="language-plaintext highlighter-rouge">Worker#runWorker()</code>方法跳出死循环，之后执行<code class="language-plaintext highlighter-rouge">processWorkerExit()</code>方法处理后续工作，而该非核心线程对应的<code class="language-plaintext highlighter-rouge">Worker</code>则变成“游离对象”，等待被JVM回收。当<code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut</code>设置为true的时候，这里分析的非核心线程的生命周期终结逻辑同时会适用于核心线程。那么可以总结出<code class="language-plaintext highlighter-rouge">keepAliveTime</code>的意义：</p>

<ul>
  <li>当允许核心线程超时，也就是<code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut</code>设置为true的时候，此时<code class="language-plaintext highlighter-rouge">keepAliveTime</code>表示空闲的工作线程的存活周期。</li>
  <li>默认情况下不允许核心线程超时，此时<code class="language-plaintext highlighter-rouge">keepAliveTime</code>表示空闲的非核心线程的存活周期。</li>
</ul>

<p>在一些特定的场景下，配置合理的<code class="language-plaintext highlighter-rouge">keepAliveTime</code>能够更好地利用线程池的工作线程资源。</p>

<h2 id="三线程池关闭">三、线程池关闭</h2>

<h3 id="shutdown">shutdown()</h3>

<p>线程池关闭操作有几个相关的变体方法，先看<code class="language-plaintext highlighter-rouge">shutdown()</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 权限校验，安全策略相关判断</span>
        <span class="n">checkShutdownAccess</span><span class="o">();</span>
        <span class="c1">// 设置SHUTDOWN状态</span>
        <span class="n">advanceRunState</span><span class="o">(</span><span class="no">SHUTDOWN</span><span class="o">);</span>
        <span class="c1">// 中断所有的空闲的工作线程</span>
        <span class="n">interruptIdleWorkers</span><span class="o">();</span>
        <span class="c1">// 钩子方法</span>
        <span class="n">onShutdown</span><span class="o">();</span> <span class="c1">// hook for ScheduledThreadPoolExecutor</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 调用上面分析果敢的尝试terminate方法，使状态更变为TIDYING，执行钩子方法terminated()后，最终状态更新为TERMINATED</span>
    <span class="n">tryTerminate</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 升提状态</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">advanceRunState</span><span class="o">(</span><span class="kt">int</span> <span class="n">targetState</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// assert targetState == SHUTDOWN || targetState == STOP;</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="c1">// 线程池状态至少为targetState或者CAS设置状态为targetState则跳出循环</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">targetState</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">ctl</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">ctlOf</span><span class="o">(</span><span class="n">targetState</span><span class="o">,</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">))))</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 中断所有的空闲的工作线程</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">interruptIdleWorkers</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">interruptIdleWorkers</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>shutdown只是将当前空闲的线程和还没有进入开始执行任务的线程记性中断。但是如果线程任务已经在执行，即已经调用了task.run()方法，那么不会将其停止。具体的逻辑可以看runWorker中在进行run执行进了一些状态的判断。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">((</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">STOP</span><span class="o">)</span> <span class="o">||</span>
        <span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">STOP</span><span class="o">)))</span> <span class="o">&amp;&amp;</span>
    <span class="o">!</span><span class="n">wt</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">()</span>
   <span class="o">)</span>
    <span class="n">wt</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>  <span class="c1">// Thread wt = Thread.currentThread();</span>
</code></pre></div></div>

<h3 id="shutdownnow">shutdownNow()</h3>

<p>接着看<code class="language-plaintext highlighter-rouge">shutdownNow()</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="nf">shutdownNow</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="o">;</span>
    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 权限校验，安全策略相关判断</span>
        <span class="n">checkShutdownAccess</span><span class="o">();</span>
        <span class="c1">// 设置STOP状态</span>
        <span class="n">advanceRunState</span><span class="o">(</span><span class="no">STOP</span><span class="o">);</span>
        <span class="c1">// 中断所有的工作线程</span>
        <span class="n">interruptWorkers</span><span class="o">();</span>
        <span class="c1">// 清空工作队列并且取出所有的未执行的任务</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="n">drainQueue</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
     <span class="c1">// 调用上面分析果敢的尝试terminate方法，使状态更变为TIDYING，执行钩子方法terminated()后，最终状态更新为TERMINATED</span>
    <span class="n">tryTerminate</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">tasks</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 遍历所有的工作线程，如果state &gt; 0（启动状态）则进行中断</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">interruptWorkers</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// assert mainLock.isHeldByCurrentThread();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span>
        <span class="n">w</span><span class="o">.</span><span class="na">interruptIfStarted</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 调用worker中的中断方法， 相当于直接调用Thread的中断方法，会将线程停止下来。</span>
<span class="kt">void</span> <span class="nf">interruptIfStarted</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Thread</span> <span class="n">t</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">getState</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">thread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SecurityException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">shutdownNow()</code>方法会把线程池状态先更变为<code class="language-plaintext highlighter-rouge">STOP</code>，中断所有的工作线程（<code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code>的<code class="language-plaintext highlighter-rouge">state</code>值大于0的<code class="language-plaintext highlighter-rouge">Worker</code>实例，也就是包括正在执行任务的<code class="language-plaintext highlighter-rouge">Worker</code>和空闲的<code class="language-plaintext highlighter-rouge">Worker</code>），然后遍历任务队列，取出（移除）所有任务存放在一个列表中返回。</p>

<p>最后看<code class="language-plaintext highlighter-rouge">awaitTermination()</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">awaitTermination</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="c1">// 转换timeout的单位为纳秒</span>
    <span class="kt">long</span> <span class="n">nanos</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">);</span>
    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 循环等待直到线程池状态更变为TERMINATED，每轮循环等待nanos纳秒</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">runStateLessThan</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">TERMINATED</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&lt;=</span> <span class="mi">0L</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">nanos</span> <span class="o">=</span> <span class="n">termination</span><span class="o">.</span><span class="na">awaitNanos</span><span class="o">(</span><span class="n">nanos</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">awaitTermination()</code>虽然不是<code class="language-plaintext highlighter-rouge">shutdown()</code>方法体系，但是它的处理逻辑就是确保调用此方法的线程会阻塞到<code class="language-plaintext highlighter-rouge">tryTerminate()</code>方法成功把线程池状态更新为<code class="language-plaintext highlighter-rouge">TERMINATED</code>后再返回，可以使用在某些需要感知线程池终结时刻的场景。</p>

<p>有一点值得关注的是：<code class="language-plaintext highlighter-rouge">shutdown()</code>方法<strong>只会中断空闲的工作线程</strong>，如果工作线程正在执行任务对象<code class="language-plaintext highlighter-rouge">Runnable#run()</code>，这种情况下的工作线程不会中断，而是等待下一轮执行<code class="language-plaintext highlighter-rouge">getTask()</code>方法的时候通过线程池状态判断正常终结该工作线程。</p>

<h3 id="processworkerexit">processWorkerExit()</h3>

<p><code class="language-plaintext highlighter-rouge">processWorkerExit()</code>方法是为将要终结的<code class="language-plaintext highlighter-rouge">Worker</code>做一次清理和数据记录工作（因为<code class="language-plaintext highlighter-rouge">processWorkerExit()</code>方法也包裹在<code class="language-plaintext highlighter-rouge">runWorker()</code>方法<code class="language-plaintext highlighter-rouge">finally</code>代码块中，其实工作线程在执行完<code class="language-plaintext highlighter-rouge">processWorkerExit()</code>方法才算真正的终结）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">processWorkerExit</span><span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">completedAbruptly</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 因为抛出用户异常导致线程终结，直接使工作线程数减1即可</span>
    <span class="c1">// 如果没有任何异常抛出的情况下是通过getTask()返回null引导线程正常跳出runWorker()方法的while死循环从而正常终结，这种情况下，在getTask()中已经把线程数减1</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">completedAbruptly</span><span class="o">)</span> <span class="c1">// If abrupt, then workerCount wasn't adjusted</span>
        <span class="n">decrementWorkerCount</span><span class="o">();</span>

    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 全局的已完成任务记录数加上此将要终结的Worker中的已完成任务数</span>
        <span class="n">completedTaskCount</span> <span class="o">+=</span> <span class="n">w</span><span class="o">.</span><span class="na">completedTasks</span><span class="o">;</span>
        <span class="c1">// 工作线程集合中移除此将要终结的Worker</span>
        <span class="n">workers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
     
    <span class="c1">// 见下一小节分析，用于根据当前线程池的状态判断是否需要进行线程池terminate处理</span>
    <span class="n">tryTerminate</span><span class="o">();</span>

    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="c1">// 如果线程池的状态小于STOP，也就是处于RUNNING或者SHUTDOWN状态的前提下：</span>
    <span class="c1">// 1.如果线程不是由于抛出用户异常终结，如果允许核心线程超时，则保持线程池中至少存在一个工作线程</span>
    <span class="c1">// 2.如果线程由于抛出用户异常终结，或者当前工作线程数，那么直接添加一个新的非核心线程</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">runStateLessThan</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">STOP</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">completedAbruptly</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果允许核心线程超时，最小值为0，否则为corePoolSize</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">allowCoreThreadTimeOut</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">corePoolSize</span><span class="o">;</span>
            <span class="c1">// 如果最小值为0，同时任务队列不空，则更新最小值为1</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">min</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                <span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// 工作线程数大于等于最小值，直接返回不新增非核心线程</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="o">)</span>
                <span class="k">return</span><span class="o">;</span> <span class="c1">// replacement not needed</span>
        <span class="o">}</span>
        <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>代码的后面部分区域，会判断线程池的状态，如果线程池是<code class="language-plaintext highlighter-rouge">RUNNING</code>或者<code class="language-plaintext highlighter-rouge">SHUTDOWN</code>状态的前提下，如果当前的工作线程由于抛出用户异常被终结，那么会新创建一个非核心线程。如果当前的工作线程并不是抛出用户异常被终结（正常情况下的终结），那么会这样处理：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut</code>为true，也就是允许核心线程超时的前提下，如果任务队列空，则会通过创建一个非核心线程保持线程池中至少有一个工作线程。</li>
  <li><code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut</code>为false，如果工作线程总数大于<code class="language-plaintext highlighter-rouge">corePoolSize</code>则直接返回，否则创建一个非核心线程，也就是会趋向于保持线程池中的工作线程数量趋向于<code class="language-plaintext highlighter-rouge">corePoolSize</code>。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">processWorkerExit()</code>执行完毕之后，意味着该工作线程的生命周期已经完结。</p>

<h3 id="tryterminate">tryTerminate()</h3>

<p>每个工作线程终结的时候都会调用<code class="language-plaintext highlighter-rouge">tryTerminate()</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">void</span> <span class="nf">tryTerminate</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="c1">// 判断线程池的状态，如果是下面三种情况下的任意一种则直接返回：</span>
        <span class="c1">// 1.线程池处于RUNNING状态</span>
        <span class="c1">// 2.线程池至少为TIDYING状态，也就是TIDYING或者TERMINATED状态，意味着已经走到了下面的步骤，线程池即将终结</span>
        <span class="c1">// 3.线程池至少为STOP状态并且任务队列不为空</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">TIDYING</span><span class="o">)</span> <span class="o">||</span>
            <span class="o">(</span><span class="n">runStateLessThan</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="no">STOP</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="c1">// 工作线程数不为0，则中断工作线程集合中的第一个空闲的工作线程</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Eligible to terminate</span>
            <span class="n">interruptIdleWorkers</span><span class="o">(</span><span class="no">ONLY_ONE</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// CAS设置线程池状态为TIDYING，如果设置成功则执行钩子方法terminated()</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">ctlOf</span><span class="o">(</span><span class="no">TIDYING</span><span class="o">,</span> <span class="mi">0</span><span class="o">)))</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">terminated</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="c1">// 最后更新线程池状态为TERMINATED</span>
                    <span class="n">ctl</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">ctlOf</span><span class="o">(</span><span class="no">TERMINATED</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
                    <span class="c1">// 唤醒阻塞在termination条件的所有线程，这个变量的await()方法在awaitTermination()中调用</span>
                    <span class="n">termination</span><span class="o">.</span><span class="na">signalAll</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// else retry on failed CAS</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 中断空闲的工作线程，onlyOne为true的时候，只会中断工作线程集合中的某一个线程</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">interruptIdleWorkers</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">onlyOne</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">thread</span><span class="o">;</span>
            <span class="c1">// 这里判断线程不是中断状态并且尝试获取锁成功的时候才进行线程中断</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">t</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="o">.</span><span class="na">tryLock</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SecurityException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// 这里跳出循环，也就是只中断集合中第一个工作线程</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">onlyOne</span><span class="o">)</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里有疑惑的地方是<code class="language-plaintext highlighter-rouge">tryTerminate()</code>方法的第二个<code class="language-plaintext highlighter-rouge">if</code>代码逻辑：工作线程数不为0，则中断工作线程集合中的第一个空闲的工作线程。方法API注释中有这样一段话：</p>

<blockquote>
  <p>If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate.
当满足终结线程池的条件但是工作线程数不为0，这个时候需要中断一个空闲的工作线程去确保线程池关闭的信号得以传播。</p>
</blockquote>

<p>下面将会分析的<code class="language-plaintext highlighter-rouge">shutdown()</code>方法中会通过<code class="language-plaintext highlighter-rouge">interruptIdleWorkers()</code>中断所有的空闲线程，这个时候有可能有非空闲的线程在执行某个任务，执行任务完毕之后，如果它刚好是核心线程，就会在下一轮循环阻塞在任务队列的<code class="language-plaintext highlighter-rouge">take()</code>方法，如果不做额外的干预，它甚至会在线程池关闭之后永久阻塞在任务队列的<code class="language-plaintext highlighter-rouge">take()</code>方法中。为了避免这种情况，每个工作线程退出的时候都会尝试中断工作线程集合中的某一个空闲的线程，确保所有空闲的线程都能够正常退出。</p>

<p><code class="language-plaintext highlighter-rouge">interruptIdleWorkers()</code>方法中会对每一个工作线程先进行<code class="language-plaintext highlighter-rouge">tryLock()</code>判断，只有返回<code class="language-plaintext highlighter-rouge">true</code>才有可能进行线程中断。我们知道<code class="language-plaintext highlighter-rouge">runWorker()</code>方法中，工作线程在每次从任务队列中获取到非null的任务之后，会先进行加锁<code class="language-plaintext highlighter-rouge">Worker#lock()</code>操作，这样就能避免线程在执行任务的过程中被中断，保证被中断的一定是空闲的工作线程。</p>

<h2 id="reject">reject()</h2>

<p><code class="language-plaintext highlighter-rouge">reject(Runnable command)</code>方法很简单：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">void</span> <span class="nf">reject</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">handler</span><span class="o">.</span><span class="na">rejectedExecution</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>调用线程池持有的成员<code class="language-plaintext highlighter-rouge">RejectedExecutionHandler</code>实例回调任务实例和当前线程池实例。</p>

<h2 id="钩子方法分析">钩子方法分析</h2>

<p>到JDK11为止，<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>提供的钩子方法没有增加，有以下几个：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">beforeExecute(Thread t, Runnable r)</code>：任务对象<code class="language-plaintext highlighter-rouge">Runnable#run()</code>执行之前触发回调。</li>
  <li><code class="language-plaintext highlighter-rouge">afterExecute(Runnable r, Throwable t)</code>：任务对象<code class="language-plaintext highlighter-rouge">Runnable#run()</code>执行之后（包括异常完成情况和正常完成情况）触发回调。</li>
  <li><code class="language-plaintext highlighter-rouge">terminated()</code>：线程池关闭的时候，状态更变为<code class="language-plaintext highlighter-rouge">TIDYING</code>成功之后会回调此方法，执行此方法完毕后，线程池状态会更新为<code class="language-plaintext highlighter-rouge">TERMINATED</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">onShutdown()</code>：<code class="language-plaintext highlighter-rouge">shutdown()</code>方法执行时候会回调此方法，API注释中提到此方法主要提供给<code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code>使用。</li>
</ul>

<p>其中<code class="language-plaintext highlighter-rouge">onShutdown()</code>的方法修饰符为<code class="language-plaintext highlighter-rouge">default</code>，其他三个方法的修饰符为<code class="language-plaintext highlighter-rouge">protected</code>，必要时候可以自行扩展这些方法，可以实现监控、基于特定时机触发具体操作等等。</p>

<h2 id="其他方法">其他方法</h2>

<p>线程池本身提供了大量数据统计相关的方法、扩容方法、预创建方法等等，这些方法的源码并不复杂，这里不做展开分析。</p>

<p><strong>核心线程相关：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getCorePoolSize()</code>：获取核心线程数。</li>
  <li><code class="language-plaintext highlighter-rouge">setCorePoolSize()</code>：重新设置线程池的核心线程数。</li>
  <li><code class="language-plaintext highlighter-rouge">prestartCoreThread()</code>：预启动一个核心线程，当且仅当工作线程数量小于核心线程数量。</li>
  <li><code class="language-plaintext highlighter-rouge">prestartAllCoreThreads()</code>：预启动所有核心线程。</li>
</ul>

<p><strong>线程池容量相关：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getMaximumPoolSize()</code>：获取线程池容量。</li>
  <li><code class="language-plaintext highlighter-rouge">setMaximumPoolSize()</code>：重新设置线程池的最大容量。</li>
</ul>

<p><strong>线程存活周期相关：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setKeepAliveTime()</code>：设置空闲工作线程的存活周期。</li>
  <li><code class="language-plaintext highlighter-rouge">getKeepAliveTime()</code>：获取空闲工作线程的存活周期。</li>
</ul>

<p><strong>其他监控统计相关方法：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getTaskCount()</code>：获取所有已经被执行的任务总数的近似值。</li>
  <li><code class="language-plaintext highlighter-rouge">getCompletedTaskCount()</code>：获取所有已经执行完成的任务总数的近似值。</li>
  <li><code class="language-plaintext highlighter-rouge">getLargestPoolSize()</code>：获取线程池的峰值线程数（最大池容量）。</li>
  <li><code class="language-plaintext highlighter-rouge">getActiveCount()</code>：获取所有活跃线程总数（正在执行任务的工作线程）的近似值。</li>
  <li><code class="language-plaintext highlighter-rouge">getPoolSize()</code>：获取工作线程集合的容量（当前线程池中的总工作线程数）。</li>
</ul>

<p><strong>任务队列操作相关方法：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">purge()</code>：移除任务队列中所有是<code class="language-plaintext highlighter-rouge">Future</code>类型并且已经处于<code class="language-plaintext highlighter-rouge">Cancelled</code>状态的任务。</li>
  <li><code class="language-plaintext highlighter-rouge">remove()</code>：从任务队列中移除指定的任务。</li>
  <li><code class="language-plaintext highlighter-rouge">BlockingQueue&lt;Runnable&gt; getQueue()</code>：获取任务队列的引用。</li>
</ul>

<h2 id="小结">小结</h2>

<p>总的来说线程池就是以上的运行流程，其中所有的worker 都被存储在HashSet中，因为HashSet不是线程安全的，当需要添加worker或者是删除worker的时候，都需要进行申请ThreadPoolExecutor中的内部类锁<code class="language-plaintext highlighter-rouge">mainLock</code>，这个是一个ReentrantLock类型的锁，调用的场景也就限定在更新内部属性的时候，防止多线程竞争，需要知道的是，只有操作线程池对象的线程才能修改线程池的属性，比如调用shutdown()方法，还有就是当主线程去调用ExecutorService.execute()方法时候发现核心线程没有被创建的时候，向worker中添加线程。</p>

<p>为什么在进行runworker之前会进行unlock()方法？ 主要是因为线程池在进行创建线程的时候不能被中断，此时他的state被设置为-1，所有在运行线程的时候，需要将其state更改为0，表示此时线程是正常的。而且线程在进行质心任务的时候，还会对线程加锁，其实也不是加锁，只是设置一下state的状态，让其他线程知道当前线程在尽心执行任务。</p>

<p>参考：<a href="https://www.throwable.club/2019/07/15/java-concurrency-thread-pool-executor/">JUC线程池ThreadPoolExecutor源码分析</a></p>

  </div>

    
<footer>
    <div style="color: #B0BEC5">标签：
    
    <a class="tag" style="color: #E91E63;font-weight:bold" href="/pages/tags#java">#java</a>
    
  </div>
</footer>






  
  
  

  
  
</article>


      <footer class="site-footer">
        <!-- <span class="site-footer-owner"> 刁文杰的博客©2018-2019.</span> -->
        
      <center>
          <span class="site-footer-credits">刁文杰的博客©2018-2020.</span><br>
          <!-- <span class="site-footer-credits" style="font-size:12px">Already <span id="sitetime"></span> days.</span><br> -->
          <!-- <span class="site-footer-credits" href>浙ICP备2020039014号</span><br> -->
          <a href="http://beian.miit.gov.cn/" class="site-footer-credits"> 浙ICP备2020039014号</a> <br>
      </center>

     
        

      </footer>
    </section>

    

    
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


      <script>
          ajax()
  function ajax(option){
    var xhr = null;
    if(window.XMLHttpRequest){
      xhr = new window.XMLHttpRequest();
    }else{ // ie
      xhr = new ActiveObject("Microsoft")
    }
    xhr.open("get","");
    xhr.send(null);
    xhr.onreadystatechange = function(){
      var time = null,
          curDate = null;
      if(xhr.readyState===2){
        // Get time
        time = xhr.getResponseHeader("Date");
        console.log(xhr.getAllResponseHeaders())
        curDate = new Date(time);
        document.getElementById("sitetime").innerHTML = (parseInt((((curDate.getTime() / 1000) - 1571133419 ) / 86400 )));
        
      }
    }
  }
      </script>
      
      <script src = '/assets/js/instantclick.min.js' data-no-instant></script>
      <script data-no-instant>InstantClick.init();</script>
      
  </body>
</html>
